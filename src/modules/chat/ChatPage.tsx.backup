import React from 'react';
import { Box, Paper, Stack, TextField, IconButton, Typography, Avatar, Button, List, ListItemButton, ListItemText, Menu, MenuItem, Dialog, DialogTitle, DialogContent, DialogActions, Collapse, Divider, Chip, Alert, FormControl, InputLabel, Select } from '@mui/material';
import AddIcon from '@mui/icons-material/Add';
import ZoomInIcon from '@mui/icons-material/ZoomIn';
import SaveIcon from '@mui/icons-material/Save';
import { useSearchParams, useNavigate } from 'react-router-dom';
import { streamOllamaChat, OllamaChatMessage } from '../../services/ollama';
import { getSettings, getAppSettings } from '../../services/settings';
import { backendApiService, ChatMessage as BackendChatMessage } from '../../services/backendApiService';
import { gptImageService, ImageGenerationResult } from '../../services/gptImageService';
import { actionExecutorService, ActionExecutionResult } from '../../services/actionExecutorService';
import { selectBestAction } from '../../services/actionLibrary';
import { splitThinking } from '../../utils/thinking';
import { searchKnowledgeBase, formatSearchResultsAsContext, getKnowledgeSources } from '../../services/knowledgeBase';
import { getCommands, CommandItem } from '../../services/commandService';
import BottomTodoPanel, { SimpleTodoList } from '../../components/BottomTodoPanel';
import ActionResultDisplay from '../../components/ActionResultDisplay';
import { 
  generateSimpleTodoWithLLM, 
  isMultiStepTask, 
  startTodoExecution, 
  completeCurrentAndStartNext,
  updateTodoItemStatus 
} from '../../services/simpleTodoGenerator';
import { createTodoExecutor, TodoExecutor, TodoStepResult } from '../../services/todoExecutionService';
import MoreVertIcon from '@mui/icons-material/MoreVert';
import SendIcon from '@mui/icons-material/Send';
import DeleteIcon from '@mui/icons-material/Delete';
import PsychologyIcon from '@mui/icons-material/Psychology';
import AutoAwesomeIcon from '@mui/icons-material/AutoAwesome';
import SearchIcon from '@mui/icons-material/Search';
import SmartToyIcon from '@mui/icons-material/SmartToy';
import PlaylistPlayIcon from '@mui/icons-material/PlaylistPlay';
import CloseIcon from '@mui/icons-material/Close';
import AutoFixHighIcon from '@mui/icons-material/AutoFixHigh';
import ExtensionIcon from '@mui/icons-material/Extension';

type Message = {
  id: string;
  role: 'user' | 'agent';
  text: string;
  createdAt: number;
  thinking?: string;
  executionResults?: TodoStepResult[]; // é™„åŠ çš„æ‰§è¡Œç»“æœ
  imageBase64?: string; // ç”Ÿæˆçš„å›¾åƒæ•°æ®
  isImageGeneration?: boolean; // æ ‡è®°æ˜¯å¦ä¸ºå›¾åƒç”Ÿæˆæ¶ˆæ¯
};


type Conversation = {
  id: string;
  title: string;
  messages: Message[];
  createdAt: number;
  updatedAt: number;
};

const STORAGE_KEY = 'launchbox_conversations_v1';
const MEMORY_SETTINGS_KEY = 'launchbox_memory_settings_v1';
const RAG_SETTINGS_KEY = 'launchbox_rag_settings_v1';
const TODOS_STORAGE_KEY = 'launchbox_conversation_todos_v1';
const INPUTS_STORAGE_KEY = 'launchbox_conversation_inputs_v1';
const COMMANDS_STORAGE_KEY = 'launchbox_conversation_commands_v1';

// å†…å­˜ç¼“å­˜ï¼Œç”¨äºä¿å­˜å½“å‰ä¼šè¯çš„å›¾åƒæ•°æ®
const imageCache = new Map<string, string>();

// æ£€æŸ¥localStorageä½¿ç”¨æƒ…å†µ
function getLocalStorageUsage(): { used: number; total: number; percentage: number } {
  let used = 0;
  for (const key in localStorage) {
    if (localStorage.hasOwnProperty(key)) {
      used += localStorage[key].length + key.length;
    }
  }
  
  // å¤§å¤šæ•°æµè§ˆå™¨çš„localStorageé™åˆ¶æ˜¯5MB
  const total = 5 * 1024 * 1024; // 5MB in bytes
  const percentage = (used / total) * 100;
  
  return { used, total, percentage };
}

type MemorySettings = {
  maxRounds: number; // æœ€å¤§ä¿ç•™è½®æ•°ï¼Œ0è¡¨ç¤ºæ— é™åˆ¶
};

type RAGSettings = {
  enabled: boolean;
  maxResults: number;
};


type SpecialMessage = Message & {
  type?: 'command_result' | 'action_result';
  metadata?: {
    commandName?: string;
    actionName?: string;
    actionType?: string;
    executionTime?: number;
    result?: any;
  };
};

const defaultMemorySettings: MemorySettings = {
  maxRounds: 10
};

const defaultRAGSettings: RAGSettings = {
  enabled: true,
  maxResults: 3
};

export default function ChatPage(): JSX.Element {
  const [searchParams] = useSearchParams();
  const navigate = useNavigate();
  const [conversations, setConversations] = React.useState<Conversation[]>(() => {
    const raw = localStorage.getItem(STORAGE_KEY);
    if (!raw) return [];
    
    const parsed = JSON.parse(raw) as Conversation[];
    // æ¸…ç†æ—§çš„todoMessageså­—æ®µ
    return parsed.map(conv => ({
      id: conv.id,
      title: conv.title,
      messages: conv.messages || [],
      createdAt: conv.createdAt,
      updatedAt: conv.updatedAt
    }));
  });
  const [activeId, setActiveId] = React.useState<string | null>(() => conversations[0]?.id ?? null);
  const [conversationInputs, setConversationInputs] = React.useState<Record<string, string>>(() => {
    try {
      const raw = localStorage.getItem(INPUTS_STORAGE_KEY);
      return raw ? JSON.parse(raw) : {};
    } catch (error) {
      console.error('Failed to load conversation inputs:', error);
      return {};
    }
  });
  const [expandedThinking, setExpandedThinking] = React.useState<Record<string, boolean>>({});
  const messagesEndRef = React.useRef<HTMLDivElement>(null);
  
  // è‡ªåŠ¨æ»šåŠ¨åˆ°æœ€æ–°æ¶ˆæ¯
  const scrollToBottom = (smooth: boolean = true) => {
    messagesEndRef.current?.scrollIntoView({ behavior: smooth ? 'smooth' : 'instant' });
  };

  React.useEffect(() => {
    scrollToBottom();
  }, [getActive()?.messages]);

  // å½“åˆ‡æ¢å¯¹è¯æ—¶ï¼Œç«‹å³è·³è½¬åˆ°åº•éƒ¨ï¼ˆä¸ä½¿ç”¨åŠ¨ç”»ï¼‰
  React.useEffect(() => {
    if (activeId) {
      scrollToBottom(false); // ç«‹å³è·³è½¬ï¼Œä¸ä½¿ç”¨æ»šåŠ¨åŠ¨ç”»
    }
  }, [activeId]);
  
  // è·å–å½“å‰å¯¹è¯çš„è¾“å…¥æ–‡æœ¬
  const input = activeId ? (conversationInputs[activeId] || '') : '';
  
  // è®¾ç½®å½“å‰å¯¹è¯çš„è¾“å…¥æ–‡æœ¬
  const setInput = (value: string) => {
    if (activeId) {
      setConversationInputs(prev => ({
        ...prev,
        [activeId]: value
      }));
    }
  };
  
  
  // åº•éƒ¨ç®€å•TodoçŠ¶æ€ - æŒ‰å¯¹è¯IDå­˜å‚¨
  const [conversationTodos, setConversationTodos] = React.useState<Record<string, SimpleTodoList>>(() => {
    try {
      const raw = localStorage.getItem(TODOS_STORAGE_KEY);
      return raw ? JSON.parse(raw) : {};
    } catch (error) {
      console.error('Failed to load conversation todos:', error);
      return {};
    }
  });
  const [todoExpanded, setTodoExpanded] = React.useState<Record<string, boolean>>({});
  
  // Todoæ‰§è¡Œå™¨çŠ¶æ€
  const [todoExecutors, setTodoExecutors] = React.useState<Record<string, TodoExecutor>>({});
  
  // ä¸Šä¸‹æ–‡é—®é¢˜çŠ¶æ€
  const [hasContextIssue, setHasContextIssue] = React.useState<Record<string, boolean>>({});
  const [imageModalOpen, setImageModalOpen] = React.useState<{ open: boolean; src: string }>({ open: false, src: '' });
  
  // ç›‘å¬æ‰§è¡Œå™¨çŠ¶æ€å˜åŒ–
  React.useEffect(() => {
    console.log('todoExecutorsçŠ¶æ€å˜åŒ–:', Object.keys(todoExecutors));
  }, [todoExecutors]);
  const [menuAnchor, setMenuAnchor] = React.useState<null | HTMLElement>(null);
  const [menuConvId, setMenuConvId] = React.useState<string | null>(null);
  const isMenuOpen = Boolean(menuAnchor);
  const [renameOpen, setRenameOpen] = React.useState(false);
  const [renameValue, setRenameValue] = React.useState('');
  const [deleteOpen, setDeleteOpen] = React.useState(false);
  const [clearChatOpen, setClearChatOpen] = React.useState(false);
  const [memorySettingsOpen, setMemorySettingsOpen] = React.useState(false);
  const [ragSettingsOpen, setRAGSettingsOpen] = React.useState(false);
  const [memorySettings, setMemorySettings] = React.useState<MemorySettings>(() => {
    const raw = localStorage.getItem(MEMORY_SETTINGS_KEY);
    return raw ? (JSON.parse(raw) as MemorySettings) : defaultMemorySettings;
  });
  const [ragSettings, setRAGSettings] = React.useState<RAGSettings>(() => {
    const raw = localStorage.getItem(RAG_SETTINGS_KEY);
    return raw ? (JSON.parse(raw) as RAGSettings) : defaultRAGSettings;
  });
  
  // æŒ‡ä»¤ç›¸å…³çŠ¶æ€
  const [commands, setCommands] = React.useState<CommandItem[]>([]);
  const [conversationCommands, setConversationCommands] = React.useState<Record<string, string>>(() => {
    try {
      const raw = localStorage.getItem(COMMANDS_STORAGE_KEY);
      return raw ? JSON.parse(raw) : {};
    } catch (error) {
      console.error('Failed to load conversation commands:', error);
      return {};
    }
  });
  const [commandDialogOpen, setCommandDialogOpen] = React.useState(false);
  const [commandSearchText, setCommandSearchText] = React.useState('');
  
  // æŠ€èƒ½ç›¸å…³çŠ¶æ€
  const [skillDialogOpen, setSkillDialogOpen] = React.useState<boolean>(false);
  const [selectedSkill, setSelectedSkill] = React.useState<string | null>(null);
  
  // æŠ€èƒ½åˆ—è¡¨å®šä¹‰
  const skills = [
    { id: 'image_generation', name: 'å›¾åƒç”Ÿæˆ', description: 'ç”Ÿæˆé«˜è´¨é‡å›¾åƒ' },
    // å¯ä»¥åœ¨è¿™é‡Œæ·»åŠ æ›´å¤šæŠ€èƒ½
  ];
  
  // è·å–å½“å‰å¯¹è¯çš„é€‰ä¸­æŒ‡ä»¤ID
  const selectedCommandId = activeId ? (conversationCommands[activeId] || '') : '';
  
  // è®¾ç½®å½“å‰å¯¹è¯çš„é€‰ä¸­æŒ‡ä»¤ID
  const setSelectedCommandId = (commandId: string) => {
    if (activeId) {
      setConversationCommands(prev => ({
        ...prev,
        [activeId]: commandId
      }));
    }
  };

  React.useEffect(() => {
    try {
      // åˆ›å»ºä¸€ä¸ªæ²¡æœ‰å¾ªç¯å¼•ç”¨çš„conversationså‰¯æœ¬ç”¨äºåºåˆ—åŒ–
      const serializableConversations = conversations.map(conv => ({
        ...conv,
        messages: conv.messages.map(msg => ({
          id: msg.id,
          role: msg.role,
          text: msg.text,
          createdAt: msg.createdAt,
          thinking: msg.thinking,
          imageBase64: msg.imageBase64, // ç¡®ä¿å›¾åƒæ•°æ®è¢«ä¿å­˜
          isImageGeneration: msg.isImageGeneration, // ç¡®ä¿å›¾åƒç”Ÿæˆæ ‡è®°è¢«ä¿å­˜
          // ç§»é™¤å¯èƒ½åŒ…å«å¾ªç¯å¼•ç”¨çš„executionResultsä¸­çš„reasoning
          executionResults: msg.executionResults?.map(result => ({
            ...result,
            reasoning: result.reasoning ? {
              shouldProceed: result.reasoning.shouldProceed,
              reasoning: result.reasoning.reasoning,
              waitingForData: result.reasoning.waitingForData,
              // ä¸åŒ…å«contextualInfoä»¥é¿å…å¾ªç¯å¼•ç”¨
            } : undefined
          }))
        }))
      }));
      
      const dataToSave = JSON.stringify(serializableConversations);
      localStorage.setItem(STORAGE_KEY, dataToSave);
    } catch (error) {
      console.warn('ä¿å­˜conversationsåˆ°localStorageå¤±è´¥:', error);
      
      // å¦‚æœæ˜¯å­˜å‚¨ç©ºé—´ä¸è¶³ï¼Œå°è¯•æ¸…ç†æ—§æ•°æ®åé‡è¯•
      if (error instanceof Error && error.name === 'QuotaExceededError') {
        const usage = getLocalStorageUsage();
        console.warn(`localStorageç©ºé—´ä¸è¶³ï¼Œå½“å‰ä½¿ç”¨: ${(usage.used / 1024 / 1024).toFixed(2)}MB (${usage.percentage.toFixed(1)}%)`);
        console.warn('å°è¯•æ¸…ç†æ—§æ•°æ®...');
        try {
          // æ¸…ç†æ—§çš„å¯¹è¯ï¼Œåªä¿ç•™æœ€è¿‘çš„3ä¸ª
          const recentConversations = conversations
            .sort((a, b) => b.updatedAt - a.updatedAt)
            .slice(0, 3);
          
          const cleanedData = recentConversations.map(conv => ({
            ...conv,
            messages: conv.messages.map(msg => ({
              id: msg.id,
              role: msg.role,
              text: msg.text,
              createdAt: msg.createdAt,
              thinking: msg.thinking,
              // å¯¹äºå›¾åƒæ¶ˆæ¯ï¼Œä¿ç•™æ ‡è®°ä½†ç§»é™¤base64æ•°æ®ä»¥èŠ‚çœç©ºé—´
              imageBase64: msg.imageBase64 ? '[å›¾åƒæ•°æ®å·²æ¸…ç†ä»¥èŠ‚çœå­˜å‚¨ç©ºé—´]' : undefined,
              isImageGeneration: msg.isImageGeneration,
              executionResults: msg.executionResults?.map(result => ({
                ...result,
                reasoning: result.reasoning ? {
                  shouldProceed: result.reasoning.shouldProceed,
                  reasoning: result.reasoning.reasoning,
                  waitingForData: result.reasoning.waitingForData,
                } : undefined
              }))
            }))
          }));
          
          localStorage.setItem(STORAGE_KEY, JSON.stringify(cleanedData));
          console.warn('å·²æ¸…ç†localStorageæ•°æ®ï¼Œä¿ç•™æœ€è¿‘3ä¸ªå¯¹è¯');
        } catch (retryError) {
          console.error('æ¸…ç†localStorageåä»ç„¶ä¿å­˜å¤±è´¥:', retryError);
          // æœ€åçš„é™çº§æ–¹æ¡ˆï¼šå®Œå…¨æ¸…ç©ºlocalStorage
          try {
            localStorage.removeItem(STORAGE_KEY);
            console.warn('å·²æ¸…ç©ºlocalStorageä¸­çš„å¯¹è¯æ•°æ®');
          } catch (clearError) {
            console.error('æ¸…ç©ºlocalStorageå¤±è´¥:', clearError);
          }
        }
      }
    }
  }, [conversations]);

  // æŒä¹…åŒ– conversationTodos
  React.useEffect(() => {
    try {
      localStorage.setItem(TODOS_STORAGE_KEY, JSON.stringify(conversationTodos));
    } catch (error) {
      console.error('Failed to save conversation todos:', error);
    }
  }, [conversationTodos]);

  // æŒä¹…åŒ– conversationInputs
  React.useEffect(() => {
    try {
      localStorage.setItem(INPUTS_STORAGE_KEY, JSON.stringify(conversationInputs));
    } catch (error) {
      console.error('Failed to save conversation inputs:', error);
    }
  }, [conversationInputs]);

  // æŒä¹…åŒ– conversationCommands
  React.useEffect(() => {
    try {
      localStorage.setItem(COMMANDS_STORAGE_KEY, JSON.stringify(conversationCommands));
    } catch (error) {
      console.error('Failed to save conversation commands:', error);
    }
  }, [conversationCommands]);

  React.useEffect(() => {
    localStorage.setItem(MEMORY_SETTINGS_KEY, JSON.stringify(memorySettings));
  }, [memorySettings]);

  React.useEffect(() => {
    localStorage.setItem(RAG_SETTINGS_KEY, JSON.stringify(ragSettings));
  }, [ragSettings]);

  // åŠ è½½æŒ‡ä»¤æ•°æ®
  React.useEffect(() => {
    setCommands(getCommands());
  }, []);

  function generateId(): string {
    if (typeof crypto !== 'undefined' && 'randomUUID' in crypto) {
      return (crypto as Crypto).randomUUID();
    }
    return `msg_${Date.now()}_${Math.random().toString(36).slice(2, 8)}`;
  }

  function upsertConversation(updater: (prev: Conversation[]) => Conversation[]): void {
    setConversations(prev => updater(prev));
  }

  function getActive(): Conversation | undefined {
    const conversation = conversations.find(c => c.id === activeId);
    if (!conversation) return undefined;
    
    // ä»å†…å­˜ç¼“å­˜ä¸­æ¢å¤å›¾åƒæ•°æ®
    const messagesWithImages = conversation.messages.map(msg => {
      if (msg.isImageGeneration === false && !msg.imageBase64 && imageCache.has(msg.id)) {
        return {
          ...msg,
          imageBase64: imageCache.get(msg.id)
        };
      }
      return msg;
    });
    
    return {
      ...conversation,
      messages: messagesWithImages
    };
  }
  
  function getCurrentTodo(): SimpleTodoList | null {
    return activeId ? conversationTodos[activeId] || null : null;
  }
  
  function setCurrentTodo(todo: SimpleTodoList | null): void {
    if (activeId) {
      setConversationTodos(prev => {
        if (todo === null) {
          const { [activeId]: removed, ...rest } = prev;
          return rest;
        }
        return { ...prev, [activeId]: todo };
      });
    }
  }

  function pushMessage(partial: Omit<Message, 'id' | 'createdAt'>): void {
    const now = Date.now();
    upsertConversation(prev => prev.map(c => c.id === activeId ? {
      ...c,
      messages: [...c.messages, { id: generateId(), createdAt: now, ...partial }],
      updatedAt: now
    } : c));
  }

  // å¤„ç†å›¾åƒç”Ÿæˆï¼ˆé€šè¿‡Actionåº“ï¼‰
  async function handleImageGeneration(message: string): Promise<void> {
    const prompt = gptImageService.extractImagePrompt(message);

    // ç”Ÿæˆå”¯ä¸€ID
    const messageId = generateId();
    const now = Date.now();

    // æ˜¾ç¤ºç”Ÿæˆä¸­çš„æ¶ˆæ¯
    const generatingMessage: Message = {
      id: messageId,
      role: 'agent',
      text: 'æ­£åœ¨ä¸ºæ‚¨ç”Ÿæˆå›¾åƒï¼Œè¯·ç¨å€™...',
      createdAt: now,
      isImageGeneration: true
    };

    // ç›´æ¥ä½¿ç”¨upsertConversationæ¥æ·»åŠ æ¶ˆæ¯ï¼Œç¡®ä¿IDä¸€è‡´
    upsertConversation(prev => prev.map(c => c.id === activeId ? {
      ...c,
      messages: [...c.messages, generatingMessage],
      updatedAt: now
    } : c));

    try {
      // é€šè¿‡Actionæ‰§è¡ŒæœåŠ¡è°ƒç”¨å›¾åƒç”Ÿæˆ
      const result = await actionExecutorService.executeImageGeneration(prompt, 1536, 1024);

      // å¦‚æœå›¾åƒç”ŸæˆæˆåŠŸï¼Œå°†å›¾åƒæ•°æ®ä¿å­˜åˆ°å†…å­˜ç¼“å­˜
      if (result.success && result.data?.image_base64) {
        imageCache.set(messageId, result.data.image_base64);
      }

      // æ›´æ–°æ¶ˆæ¯å†…å®¹
      upsertConversation(prev => prev.map(conv => {
        if (conv.id === activeId) {
          return {
            ...conv,
            messages: conv.messages.map(msg =>
              msg.id === messageId
                ? {
                    ...msg,
                    text: result.success
                      ? "å·²ä¸ºæ‚¨ç”Ÿæˆå›¾åƒ"
                      : `å›¾åƒç”Ÿæˆå¤±è´¥ï¼š${result.error}`,
                    imageBase64: result.success ? result.data?.image_base64 : undefined,
                    isImageGeneration: false // æ¸…é™¤ç”Ÿæˆä¸­æ ‡è®°
                  }
                : msg
            ),
            updatedAt: Date.now()
          };
        }
        return conv;
      }));

    } catch (error) {
      // æ›´æ–°ä¸ºé”™è¯¯æ¶ˆæ¯
      upsertConversation(prev => prev.map(conv => {
        if (conv.id === activeId) {
          return {
            ...conv,
            messages: conv.messages.map(msg =>
              msg.id === messageId
                ? {
                    ...msg,
                    text: `å›¾åƒç”Ÿæˆå¤±è´¥ï¼š${error instanceof Error ? error.message : String(error)}`,
                    isImageGeneration: false // æ¸…é™¤ç”Ÿæˆä¸­æ ‡è®°
                  }
                : msg
            ),
            updatedAt: Date.now()
          };
        }
        return conv;
      }));
    }
  }

  async function handleAIResponse(): Promise<void> {
    if (!activeId) {
      const firstMessage = getActive()?.messages?.[0]?.text;
      handleNewConversation(firstMessage?.slice(0, 12) || 'æ–°å¯¹è¯');
    }

    const currentMessages = getActive()?.messages ?? [];
    const lastUserMessage = currentMessages.filter(m => m.role === 'user').pop()?.text || '';
    
    // RAGæ£€ç´¢ï¼ˆå¦‚æœå¯ç”¨ï¼‰
    let contextualPrompt = lastUserMessage;
    if (ragSettings.enabled) {
      try {
        const knowledgeSources = getKnowledgeSources();
        if (knowledgeSources.some(source => source.status === 'active')) {
          const searchResults = await searchKnowledgeBase(lastUserMessage, ragSettings.maxResults);
          if (searchResults.length > 0) {
            const context = formatSearchResultsAsContext(searchResults);
            contextualPrompt = `${context}\n\n${lastUserMessage}`;
          }
        }
      } catch (error) {
        console.error('RAGæ£€ç´¢å¤±è´¥:', error);
      }
    }

    const appSettings = getAppSettings();
    const assistantId = generateId();
    const startTs = Date.now();
    
    // åˆ›å»ºåŠ©æ‰‹æ¶ˆæ¯
    upsertConversation(prev => prev.map(c => c.id === activeId ? {
      ...c,
      messages: [...c.messages, { id: assistantId, role: 'agent', text: '', createdAt: startTs }],
      updatedAt: startTs
    } : c));

    try {
      if (appSettings.useBackendApi) {
        // ä½¿ç”¨åç«¯OpenAI API
        const trimmedMessages = trimMessagesForMemory(currentMessages);
        const backendMessages: BackendChatMessage[] = trimmedMessages.map(m => ({
          role: m.role === 'agent' ? 'assistant' : 'user',
          content: m.text
        }));
        
        // æ·»åŠ å½“å‰ç”¨æˆ·æ¶ˆæ¯
        backendMessages.push({
          role: 'user',
          content: contextualPrompt
        });

        // ä½¿ç”¨æµå¼API
        await backendApiService.startStreamingChat(
          backendMessages,
          (chunk: string) => {
            // å¤„ç†æµå¼å“åº”å—
            const now = Date.now();
            upsertConversation(prev => prev.map(c => {
              if (c.id !== activeId) return c;
              const nextMessages = c.messages.map(m => {
                if (m.id !== assistantId) return m;
                const merged = m.text + chunk;
                const { visible, thinking } = splitThinking(merged);
                return { ...m, text: visible, thinking };
              });
              return { ...c, messages: nextMessages, updatedAt: now };
            }));
          },
          () => {
            // å®Œæˆå›è°ƒ
            console.log('Backend streaming completed');
          },
          (error: string) => {
            // é”™è¯¯å›è°ƒ
            console.error('Backend streaming error:', error);
            pushMessage({ role: 'agent', text: `âŒ åç«¯APIè°ƒç”¨å¤±è´¥: ${error}` });
          }
        );
      } else {
        // ä½¿ç”¨åŸæ¥çš„Ollama
        const trimmedMessages = trimMessagesForMemory(currentMessages);
        const history: OllamaChatMessage[] = trimmedMessages.map(m => ({
          role: m.role === 'agent' ? 'assistant' : 'user',
          content: m.text
        }));

        for await (const chunk of streamOllamaChat([...history, { role: 'user', content: contextualPrompt }])) {
          const now = Date.now();
          upsertConversation(prev => prev.map(c => {
            if (c.id !== activeId) return c;
            const nextMessages = c.messages.map(m => {
              if (m.id !== assistantId) return m;
              const merged = m.text + chunk;
              const { visible, thinking } = splitThinking(merged);
              return { ...m, text: visible, thinking };
            });
            return { ...c, messages: nextMessages, updatedAt: now };
          }));
        }
      }
    } catch (e) {
      const err = e as Error;
      const serviceName = appSettings.useBackendApi ? 'Backend API' : 'Ollama';
      pushMessage({ role: 'agent', text: `âŒ è°ƒç”¨ ${serviceName} å¤±è´¥: ${err.message}` });
    }
  }

  function handleNewConversation(initialTitle?: string): void {
    const now = Date.now();
    const id = generateId();
    const newConv: Conversation = { id, title: initialTitle || 'æ–°å¯¹è¯', messages: [], createdAt: now, updatedAt: now };
    setConversations(prev => [newConv, ...prev]);
    setActiveId(id);
  }

  async function handleNewConversationAndSend(message: string): Promise<void> {
    const now = Date.now();
    const id = generateId();
    const newConv: Conversation = { id, title: 'æ–°å¯¹è¯', messages: [], createdAt: now, updatedAt: now };
    
    // åŒæ­¥åˆ›å»ºå¯¹è¯å¹¶è®¾ç½®ä¸ºæ´»è·ƒ
    setConversations(prev => [newConv, ...prev]);
    setActiveId(id);
    
    // ç­‰å¾…çŠ¶æ€æ›´æ–°ï¼Œç„¶åå‘é€æ¶ˆæ¯
    // ä½¿ç”¨ React çš„æ‰¹å¤„ç†æœºåˆ¶ï¼Œåœ¨ä¸‹ä¸€ä¸ªäº‹ä»¶å¾ªç¯ä¸­æ‰§è¡Œ
    setTimeout(async () => {
      await handleIntelligentSend(message);
    }, 0);
  }

  function handleRenameConversation(id: string, title: string): void {
    upsertConversation(prev => prev.map(c => c.id === id ? { ...c, title, updatedAt: Date.now() } : c));
  }

  function handleDeleteConversation(id: string): void {
    setConversations(prev => {
      const updated = prev.filter(c => c.id !== id);
      // å¦‚æœåˆ é™¤çš„æ˜¯å½“å‰æ´»è·ƒå¯¹è¯ï¼Œéœ€è¦åˆ‡æ¢åˆ°å…¶ä»–å¯¹è¯
      if (activeId === id) {
        setActiveId(updated[0]?.id ?? null);
      }
      return updated;
    });
    
    // æ¸…é™¤è¢«åˆ é™¤å¯¹è¯çš„ç›¸å…³æ•°æ®
    setConversationTodos(prev => {
      const { [id]: removed, ...rest } = prev;
      return rest;
    });
    
    setTodoExpanded(prev => {
      const { [id]: removed, ...rest } = prev;
      return rest;
    });
    
    setTodoExecutors(prev => {
      const { [id]: removed, ...rest } = prev;
      return rest;
    });
    
    // æ¸…é™¤è¾“å…¥æ¡†å’ŒæŒ‡ä»¤é€‰æ‹©çŠ¶æ€
    setConversationInputs(prev => {
      const { [id]: removed, ...rest } = prev;
      return rest;
    });
    
    setConversationCommands(prev => {
      const { [id]: removed, ...rest } = prev;
      return rest;
    });
  }

  function handleClearCurrentChat(): void {
    if (!activeId) return;
    
    // æ¸…é™¤èŠå¤©è®°å½•
    setConversations(prev => prev.map(c => 
      c.id === activeId 
        ? { ...c, messages: [], updatedAt: Date.now() }
        : c
    ));
    
    // æ¸…é™¤æ€è€ƒè¿‡ç¨‹å±•å¼€çŠ¶æ€
    setExpandedThinking({});
    
    // æ¸…é™¤å½“å‰å¯¹è¯çš„Todoæ•°æ®
    setConversationTodos(prev => {
      const { [activeId]: removed, ...rest } = prev;
      return rest;
    });
    
    // æ¸…é™¤å½“å‰å¯¹è¯çš„Todoå±•å¼€çŠ¶æ€
    setTodoExpanded(prev => {
      const { [activeId]: removed, ...rest } = prev;
      return rest;
    });
    
    // æ¸…é™¤å½“å‰å¯¹è¯çš„Todoæ‰§è¡Œå™¨
    console.log('handleClearCurrentChat: æ¸…é™¤æ‰§è¡Œå™¨', activeId);
    setTodoExecutors(prev => {
      const { [activeId]: removed, ...rest } = prev;
      console.log('æ¸…é™¤æ‰§è¡Œå™¨åå‰©ä½™:', Object.keys(rest));
      return rest;
    });
    
    // æ¸…é™¤å½“å‰å¯¹è¯çš„è¾“å…¥æ¡†å’ŒæŒ‡ä»¤é€‰æ‹©çŠ¶æ€
    setConversationInputs(prev => {
      const { [activeId]: removed, ...rest } = prev;
      return rest;
    });
    
    setConversationCommands(prev => {
      const { [activeId]: removed, ...rest } = prev;
      return rest;
    });
  }

  async function handleSend(): Promise<void> {
    if (!input.trim()) return;
    
    const userMessage = input.trim();
    setInput('');
    
    // å¦‚æœæ²¡æœ‰æ´»è·ƒå¯¹è¯ï¼Œåˆ›å»ºä¸€ä¸ªæ–°å¯¹è¯å¹¶å‘é€æ¶ˆæ¯
    if (!activeId) {
      handleNewConversationAndSend(userMessage);
      return;
    }
    
    // ç»Ÿä¸€å¤„ç†æ‰€æœ‰è¾“å…¥
    await handleIntelligentSend(userMessage);
  }

  async function handleIntelligentSend(message: string): Promise<void> {
    pushMessage({ role: 'user', text: message });
    
    // é¦–å…ˆæ£€æŸ¥æ˜¯å¦æœ‰å¾…å¤„ç†çš„ç”¨æˆ·è¾“å…¥ä»»åŠ¡
    const pendingUserInput = checkForPendingUserInput();
    if (pendingUserInput) {
      // å¤„ç†ç”¨æˆ·è¾“å…¥å“åº”
      await handleUserInputResponse(pendingUserInput, message);
      return;
    }
    
        // æ£€æŸ¥æ˜¯å¦é€‰ä¸­äº†å›¾åƒç”ŸæˆæŠ€èƒ½ï¼Œæˆ–è€…é€šè¿‡å…³é”®è¯æ£€æµ‹åˆ°å›¾åƒç”Ÿæˆè¯·æ±‚
        if (selectedSkill === 'image_generation') {
          await handleImageGeneration(message);
          return;
        }
        
        // å¦‚æœæ²¡æœ‰é€‰ä¸­æŠ€èƒ½ï¼Œåˆ™é€šè¿‡å…³é”®è¯æ£€æµ‹
        const selectedAction = selectBestAction(message);
        if (selectedAction && selectedAction.type === 'å›¾åƒç”Ÿæˆ') {
          await handleImageGeneration(message);
          return;
        }
    
    // æ£€æŸ¥æ˜¯å¦é€‰æ‹©äº†æŒ‡ä»¤æ¨¡æ¿
    const selectedCommand = selectedCommandId ? commands.find(cmd => cmd.id === selectedCommandId) : null;
    
    // å¦‚æœé€‰æ‹©äº†æŒ‡ä»¤æ¨¡æ¿ï¼Œæˆ–è€…æ˜¯å¤šæ­¥éª¤ä»»åŠ¡ï¼Œåˆ™ç”ŸæˆTodo - å·²ç¦ç”¨TODOåŠŸèƒ½
    if (false && (selectedCommand || isMultiStepTask(message))) {
      // æ˜¾ç¤ºå›ºå®šçš„è®¡åˆ’åˆ¶å®šæ¶ˆæ¯
      const templateInfo = selectedCommand ? `ï¼ˆåŸºäºæŒ‡ä»¤æ¨¡æ¿ï¼š${selectedCommand.name}ï¼‰` : '';
      pushMessage({ 
        role: 'agent', 
        text: `å·²ç»æ”¶åˆ°ä½ çš„éœ€æ±‚${templateInfo}ï¼Œæ­£åœ¨åˆ¶å®šè®¡åˆ’â€¦` 
      });
      
      try {
        let enhancedMessage = message;
        
        if (selectedCommand) {
          enhancedMessage = `è¯·æŒ‰ç…§ä»¥ä¸‹æŒ‡ä»¤æ¨¡æ¿åˆ¶å®šè¯¦ç»†çš„æ‰§è¡Œè®¡åˆ’ï¼š

æŒ‡ä»¤æ¨¡æ¿ï¼š${selectedCommand.name}
ä»»åŠ¡æ­¥éª¤ï¼š
${selectedCommand.todoList}

ç”¨æˆ·éœ€æ±‚ï¼š${message}

è¯·æ ¹æ®ç”¨æˆ·çš„å…·ä½“éœ€æ±‚ï¼Œå‚è€ƒä¸Šè¿°æ¨¡æ¿æ­¥éª¤ï¼Œåˆ¶å®šè¯¦ç»†çš„æ‰§è¡Œè®¡åˆ’ã€‚`;
        }
        
        const simpleTodo = await generateSimpleTodoWithLLM(enhancedMessage);
        if (simpleTodo && activeId) {
          console.log('ç”ŸæˆTodoæˆåŠŸï¼ŒactiveId:', activeId);
          // åªè®¾ç½®Todoï¼Œä¿æŒdraftçŠ¶æ€ï¼Œç­‰å¾…ç”¨æˆ·æ‰‹åŠ¨ç¡®è®¤æ‰§è¡Œ
          setCurrentTodo(simpleTodo);
          
          // æ˜¾ç¤ºè®¡åˆ’ç”Ÿæˆå®Œæˆçš„æ¶ˆæ¯
          const finalTemplateInfo = selectedCommand ? `ï¼ˆåŸºäºæŒ‡ä»¤æ¨¡æ¿ï¼š${selectedCommand.name}ï¼‰` : '';
          pushMessage({ 
            role: 'agent', 
            text: `ğŸ“‹ ä»»åŠ¡æ‰§è¡Œè®¡åˆ’å·²ç”Ÿæˆ${finalTemplateInfo}ï¼Œå…±${simpleTodo.totalSteps}ä¸ªæ­¥éª¤ã€‚è¯·ç‚¹å‡»"å¼€å§‹æ‰§è¡Œ"æŒ‰é’®æ¥å¯åŠ¨ä»»åŠ¡ã€‚` 
          });
          
          // æ¸…é™¤é€‰ä¸­çš„æŒ‡ä»¤
          setSelectedCommandId('');
        } else {
          console.error('ç”ŸæˆTodoå¤±è´¥æˆ–activeIdä¸ºç©º:', { simpleTodo: !!simpleTodo, activeId });
        }
      } catch (error) {
        console.error('ç”Ÿæˆç®€å•Todoå¤±è´¥:', error);
        // å¦‚æœç”Ÿæˆå¤±è´¥ï¼Œç»§ç»­æ­£å¸¸AIå›å¤
        await handleAIResponse();
      }
    } else {
      // æ­£å¸¸AIå›å¤
      await handleAIResponse();
    }
  }
  
  // æ£€æŸ¥æ˜¯å¦æœ‰å¾…å¤„ç†çš„ç”¨æˆ·è¾“å…¥ä»»åŠ¡
  function checkForPendingUserInput(): string | null {
    const active = getActive();
    if (!active) return null;
    
    // æŸ¥æ‰¾æœ€åä¸€æ¡åŒ…å«AWAITING_USER_INPUTçš„æ¶ˆæ¯
    for (let i = active.messages.length - 1; i >= 0; i--) {
      const message = active.messages[i];
      if (message.executionResults) {
        for (const result of message.executionResults) {
          if (result.error && result.error.startsWith('AWAITING_USER_INPUT:')) {
            return result.error.split(':')[1]; // è¿”å›stepId
          }
        }
      }
    }
    
    return null;
  }
  
  // å¤„ç†ç”¨æˆ·è¾“å…¥å“åº”
  async function handleUserInputResponse(stepId: string, userResponse: string): Promise<void> {
    if (!activeId) {
      console.error('activeIdä¸ºç©ºï¼Œæ— æ³•å¤„ç†ç”¨æˆ·è¾“å…¥');
      return;
    }
    
    console.log('å¤„ç†ç”¨æˆ·è¾“å…¥å“åº”:', { stepId, userResponse, activeId });
    console.log('å½“å‰æ‰€æœ‰æ‰§è¡Œå™¨:', Object.keys(todoExecutors));
    console.log('å½“å‰TodoçŠ¶æ€:', getCurrentTodo());
    
    // è·å–å¯¹åº”çš„æ‰§è¡Œå™¨
    const executor = todoExecutors[activeId];
    console.log('æ‰¾åˆ°çš„æ‰§è¡Œå™¨:', !!executor);
    
    if (executor) {
      // è°ƒç”¨æ‰§è¡Œå™¨çš„handleUserInputæ–¹æ³•
      console.log('è°ƒç”¨æ‰§è¡Œå™¨çš„handleUserInputæ–¹æ³•');
      await executor.handleUserInput(stepId, userResponse);
      console.log('æ‰§è¡Œå™¨handleUserInputå®Œæˆ');
    } else {
      console.error('æœªæ‰¾åˆ°å¯¹åº”çš„Todoæ‰§è¡Œå™¨', { 
        activeId, 
        availableExecutors: Object.keys(todoExecutors),
        todoExecutorsCount: Object.keys(todoExecutors).length,
        currentTodo: !!getCurrentTodo()
      });
    }
  }
  
  // å¼ºåˆ¶ç»§ç»­ä¸‹ä¸€æ­¥
  function handleForceNext(): void {
    const currentTodo = getCurrentTodo();
    if (currentTodo && activeId) {
      const executor = todoExecutors[activeId];
      if (executor) {
        // æ¸…é™¤ä¸Šä¸‹æ–‡é—®é¢˜çŠ¶æ€
        setHasContextIssue(prev => ({ ...prev, [activeId]: false }));
        
        // å¼ºåˆ¶æ‰§è¡Œä¸‹ä¸€æ­¥
        executor.forceNextStep().catch(error => {
          console.error('å¼ºåˆ¶ç»§ç»­å¤±è´¥:', error);
          pushMessage({ 
            role: 'agent', 
            text: `âŒ å¼ºåˆ¶ç»§ç»­å¤±è´¥: ${error.message}` 
          });
        });
        
        // æ˜¾ç¤ºå¼ºåˆ¶ç»§ç»­æ¶ˆæ¯
        pushMessage({ 
          role: 'agent', 
          text: `ğŸ”„ å¼ºåˆ¶ç»§ç»­æ‰§è¡Œï¼Œå¿½ç•¥ä¸Šä¸‹æ–‡é—®é¢˜...` 
        });
      }
    }
  }

  // åº•éƒ¨Todoæ“ä½œå¤„ç†å‡½æ•°
  function handleBottomTodoStart(): void {
    const currentTodo = getCurrentTodo();
    if (currentTodo && activeId) {
      // åˆ›å»ºçœŸå®çš„Todoæ‰§è¡Œå™¨
      const executor = createTodoExecutor(
        currentTodo,
        handleTodoStepProgress,
        handleTodoComplete
      );
      
      // ä¿å­˜æ‰§è¡Œå™¨
      setTodoExecutors(prev => ({ ...prev, [activeId]: executor }));
      
      // æ›´æ–°TodoçŠ¶æ€ä¸ºè¿è¡Œä¸­ï¼Œå¹¶æ ‡è®°ä¸ºç”¨æˆ·å·²ç¡®è®¤ä¸”å·²å¼€å§‹
      const startedTodo = { 
        ...startTodoExecution(currentTodo), 
        userConfirmed: true,
        hasStarted: true  // æ ‡è®°ä¸ºå·²å¼€å§‹ï¼Œä¸€æ—¦è®¾ç½®å°±æ°¸è¿œä¸ä¼šé‡ç½®
      };
      setCurrentTodo(startedTodo);
      
      // å¼€å§‹æ‰§è¡Œåè‡ªåŠ¨æ”¶èµ·Todoé¢æ¿
      setTodoExpanded(prev => ({ ...prev, [activeId]: false }));
      
      // æ˜¾ç¤ºå¼€å§‹æ‰§è¡Œæ¶ˆæ¯
      pushMessage({ 
        role: 'agent', 
        text: `ğŸš€ å¼€å§‹æ‰§è¡Œä»»åŠ¡è®¡åˆ’...\n\næ­£åœ¨æ‰§è¡Œç¬¬1æ­¥ï¼š${startedTodo.items[0]?.text}` 
      });
      
      // å¼€å§‹çœŸå®æ‰§è¡Œ
      executor.start().catch(error => {
        console.error('Todoæ‰§è¡Œå¤±è´¥:', error);
        pushMessage({ 
          role: 'agent', 
          text: `âŒ ä»»åŠ¡æ‰§è¡Œå‡ºé”™: ${error.message}` 
        });
      });
    }
  }
  
  // å¤„ç†Todoæ­¥éª¤è¿›åº¦
  function handleTodoStepProgress(result: TodoStepResult): void {
    if (!activeId) return;
    
    console.log('handleTodoStepProgress å¼€å§‹:', {
      stepId: result.stepId,
      success: result.success,
      waitingForContext: result.waitingForContext,
      reasoning: result.reasoning?.reasoning,
      error: result.error,
      currentTodoStatus: getCurrentTodo()?.status,
      currentTodoUserConfirmed: getCurrentTodo()?.userConfirmed
    });
    
    // æ£€æŸ¥æ˜¯å¦æ˜¯ä¸Šä¸‹æ–‡é—®é¢˜
    if (!result.success && result.error === 'WAITING_FOR_CONTEXT') {
      // è®¾ç½®ä¸Šä¸‹æ–‡é—®é¢˜çŠ¶æ€
      setHasContextIssue(prev => ({ ...prev, [activeId]: true }));
      
      // æ˜¾ç¤ºæ¨ç†ç»“æœå’Œç­‰å¾…ä¿¡æ¯
      const contextMessage: Message = {
        id: generateId(),
        role: 'agent',
        text: `ğŸ§  **ä»»åŠ¡æ¨ç†åˆ†æ**\n\n${result.reasoning?.reasoning}\n\nâš ï¸ **ç¼ºå¤±ä¿¡æ¯**: ${result.reasoning?.waitingForData}\n\nğŸ’¡ å»ºè®®ï¼šæ‚¨å¯ä»¥é€‰æ‹©"ç»§ç»­æ‰§è¡Œ"ç­‰å¾…æ›´å¤šä¿¡æ¯ï¼Œæˆ–ç‚¹å‡»"å¼ºåˆ¶ç»§ç»­"æŒ‰é’®å¿½ç•¥æ­¤é—®é¢˜ç›´æ¥æ‰§è¡Œã€‚`,
        createdAt: Date.now(),
        executionResults: [result]
      };
      
      // æ·»åŠ åˆ°å¯¹è¯ä¸­
      upsertConversation(prev => prev.map(c => c.id === activeId ? {
        ...c,
        messages: [...c.messages, contextMessage],
        updatedAt: Date.now()
      } : c));
      
      return;
    }
    
    // æ£€æŸ¥æ˜¯å¦æ˜¯ç”¨æˆ·è¾“å…¥è¯¢é—®ï¼ˆéƒ¨åˆ†æˆåŠŸçŠ¶æ€ï¼‰
    if (!result.success && result.error === 'WAITING_FOR_USER_INPUT' && result.executionResult?.result?.partialSuccess) {
      // æ›´æ–°TodoçŠ¶æ€ä¸ºç­‰å¾…ç”¨æˆ·
      const currentTodo = getCurrentTodo();
      if (currentTodo) {
        const updatedTodo = updateTodoItemStatus(
          currentTodo, 
          result.stepId, 
          'waiting_user'
        );
        setCurrentTodo(updatedTodo);
      }
      
      // ç›´æ¥æ˜¾ç¤ºè¯¢é—®æ¶ˆæ¯
      const askMessage = result.executionResult.result.askMessage;
      const messageWithWaiting: Message = {
        id: generateId(),
        role: 'agent',
        text: askMessage,
        createdAt: Date.now(),
        executionResults: [{
          ...result,
          error: `AWAITING_USER_INPUT:${result.stepId}` // ç‰¹æ®Šæ ‡è®°åŒ…å«stepId
        }]
      };
      
      // æ·»åŠ åˆ°å¯¹è¯ä¸­
      upsertConversation(prev => prev.map(c => c.id === activeId ? {
        ...c,
        messages: [...c.messages, messageWithWaiting],
        updatedAt: Date.now()
      } : c));
      
      return;
    }
    
    // æ£€æŸ¥æ˜¯å¦æ˜¯LLMä»»åŠ¡
    if (result.success && result.executionResult?.result?.isLLMTask) {
      console.log('ğŸ¯ å¤„ç†LLMä»»åŠ¡æˆåŠŸç»“æœ:', {
        stepId: result.stepId,
        stepText: result.stepText,
        isLLMTask: result.executionResult?.result?.isLLMTask,
        method: result.executionResult?.result?.method
      });
      
      // æ›´æ–°TodoçŠ¶æ€ä¸ºå®Œæˆ
      const currentTodo = getCurrentTodo();
      if (currentTodo) {
        console.log('ğŸ“ æ›´æ–°TODOçŠ¶æ€å‰:', {
          currentStep: currentTodo.currentStep,
          totalSteps: currentTodo.totalSteps,
          status: currentTodo.status,
          items: currentTodo.items.map(i => ({ id: i.id, text: i.text, status: i.status }))
        });
        
        const updatedTodo = updateTodoItemStatus(
          currentTodo, 
          result.stepId, 
          'completed'
        );
        
        console.log('ğŸ“ æ›´æ–°TODOçŠ¶æ€å:', {
          currentStep: updatedTodo.currentStep,
          totalSteps: updatedTodo.totalSteps,
          status: updatedTodo.status,
          items: updatedTodo.items.map(i => ({ id: i.id, text: i.text, status: i.status }))
        });
        
        setCurrentTodo(updatedTodo);
      }
      
      // ç›´æ¥æ˜¾ç¤ºLLMå¤„ç†ç»“æœä½œä¸ºæ¶ˆæ¯
      const llmResponse = result.executionResult.result.llmResponse;
      const messageWithResult: Message = {
        id: generateId(),
        role: 'agent',
        text: llmResponse,
        createdAt: Date.now(),
        executionResults: [result] // ç®€åŒ–çš„æ‰§è¡Œç»“æœï¼Œåªæ˜¾ç¤ºæ ‡é¢˜
      };
      
      // æ·»åŠ åˆ°å¯¹è¯ä¸­
      upsertConversation(prev => prev.map(c => c.id === activeId ? {
        ...c,
        messages: [...c.messages, messageWithResult],
        updatedAt: Date.now()
      } : c));
      
      return;
    }
    
    // å¤„ç†å…¶ä»–ç±»å‹çš„ä»»åŠ¡ï¼ˆactionç±»å‹ï¼‰
    const currentTodo = getCurrentTodo();
    if (currentTodo) {
      const updatedTodo = updateTodoItemStatus(
        currentTodo, 
        result.stepId, 
        result.success ? 'completed' : 'failed'
      );
      setCurrentTodo(updatedTodo);
    }
    
    // ä½¿ç”¨LLMå¤„ç†æ‰§è¡Œç»“æœå¹¶ç”Ÿæˆç”¨æˆ·å›å¤
    generateLLMResponseForResult(result);
  }
  
  
  // ä½¿ç”¨LLMå¤„ç†æ‰§è¡Œç»“æœç”Ÿæˆç”¨æˆ·å›å¤
  async function generateLLMResponseForResult(result: TodoStepResult): Promise<void> {
    try {
      // æ„å»ºç»™LLMçš„æç¤ºè¯
      const prompt = buildResultPrompt(result);
      
      // è°ƒç”¨LLMç”Ÿæˆå›å¤
      const messages: OllamaChatMessage[] = [
        { role: 'user', content: prompt }
      ];
      
      let llmResponse = '';
      const stream = streamOllamaChat(messages);
      
      for await (const chunk of stream) {
        llmResponse += chunk;
      }
      
      // åˆ›å»ºåŒ…å«æ‰§è¡Œç»“æœçš„æ¶ˆæ¯
      const messageWithResult: Message = {
        id: generateId(),
        role: 'agent',
        text: llmResponse.trim(),
        createdAt: Date.now(),
        executionResults: [result] // é™„åŠ æ‰§è¡Œç»“æœ
      };
      
      // æ·»åŠ åˆ°å¯¹è¯ä¸­
      upsertConversation(prev => prev.map(c => c.id === activeId ? {
        ...c,
        messages: [...c.messages, messageWithResult],
        updatedAt: Date.now()
      } : c));
      
    } catch (error) {
      console.error('LLMå¤„ç†æ‰§è¡Œç»“æœå¤±è´¥:', error);
      
      // é™çº§å¤„ç†ï¼šç›´æ¥æ˜¾ç¤ºç®€å•çš„æ‰§è¡Œç»“æœ
      const fallbackText = result.success 
        ? `âœ… æ­¥éª¤å®Œæˆï¼š${result.stepText}`
        : `âŒ æ­¥éª¤å¤±è´¥ï¼š${result.stepText}\n\né”™è¯¯ï¼š${result.error}`;
      
      pushMessage({ 
        role: 'agent', 
        text: fallbackText,
        executionResults: [result]
      });
    }
  }
  
  // æ„å»ºç»™LLMçš„ç»“æœå¤„ç†æç¤ºè¯
  function buildResultPrompt(result: TodoStepResult): string {
    let prompt = `ä½ æ˜¯ä¸€ä¸ªæ™ºèƒ½åŠ©æ‰‹ã€‚ç”¨æˆ·åˆšåˆšæ‰§è¡Œäº†ä¸€ä¸ªä»»åŠ¡æ­¥éª¤ï¼Œè¯·æ ¹æ®æ‰§è¡Œç»“æœä¸ºç”¨æˆ·ç”Ÿæˆä¸€ä¸ªå‹å¥½ã€ç®€æ´çš„å›å¤ã€‚

ä»»åŠ¡æ­¥éª¤: ${result.stepText}
æ‰§è¡ŒçŠ¶æ€: ${result.success ? 'æˆåŠŸ' : 'å¤±è´¥'}
æ‰§è¡Œæ—¶é—´: ${result.executionTime}ms`;

    if (result.actionUsed) {
      prompt += `\nä½¿ç”¨å·¥å…·: ${result.actionUsed.name} (${result.actionUsed.type})`;
    }

    if (result.success && result.executionResult?.result) {
      const resultData = result.executionResult.result;
      prompt += `\n\næ‰§è¡Œç»“æœ:\n`;
      
      if (typeof resultData === 'object') {
        if (resultData.answer !== undefined) {
          prompt += `è®¡ç®—ç»“æœ: ${resultData.answer}`;
        } else if (resultData.response) {
          prompt += resultData.response;
        } else if (resultData.processed) {
          prompt += `å¤„ç†ç»“æœ: ${resultData.processed}`;
        } else if (resultData.wordCount !== undefined) {
          prompt += `æ–‡æœ¬ç»Ÿè®¡ - å•è¯: ${resultData.wordCount}, å­—ç¬¦: ${resultData.characterCount}`;
        } else {
          prompt += JSON.stringify(resultData, null, 2);
        }
      } else {
        prompt += String(resultData);
      }
    } else if (!result.success) {
      prompt += `\n\né”™è¯¯ä¿¡æ¯: ${result.error}`;
    }

    prompt += `\n\nè¯·ç”Ÿæˆä¸€ä¸ªç®€æ´ã€å‹å¥½çš„å›å¤ï¼Œå‘ç”¨æˆ·è¯´æ˜æ‰§è¡Œç»“æœã€‚ä¸è¦é‡å¤æ˜¾ç¤ºæŠ€æœ¯ç»†èŠ‚ï¼Œé‡ç‚¹æ˜¯ç»“æœçš„å«ä¹‰å’Œä»·å€¼ã€‚å›å¤åº”è¯¥åœ¨50å­—ä»¥å†…ã€‚`;

    return prompt;
  }
  
  // å¤„ç†Todoå®Œæˆ
  function handleTodoComplete(allResults: TodoStepResult[]): void {
    if (!activeId) return;
    
    console.log('handleTodoComplete: æ¸…ç†æ‰§è¡Œå™¨', activeId, 'ç»“æœæ•°é‡:', allResults.length);
    
    // æ›´æ–°TODOçš„æœ€ç»ˆçŠ¶æ€ä¸ºå®Œæˆ
    const currentTodo = getCurrentTodo();
    if (currentTodo) {
      console.log('ğŸ“‹ TODOæ‰§è¡Œå®Œæˆï¼Œæ›´æ–°æœ€ç»ˆçŠ¶æ€:', {
        currentStatus: currentTodo.status,
        currentStep: currentTodo.currentStep,
        totalSteps: currentTodo.totalSteps,
        allResultsSuccess: allResults.every(r => r.success)
      });
      
      // å°†æ•´ä¸ªTODOæ ‡è®°ä¸ºå®Œæˆ
      const completedTodo = {
        ...currentTodo,
        status: 'completed' as const,
        currentStep: currentTodo.totalSteps // è®¾ç½®ä¸ºæ€»æ­¥æ•°è¡¨ç¤ºå…¨éƒ¨å®Œæˆ
      };
      
      setCurrentTodo(completedTodo);
      
      // æ˜¾ç¤ºå®Œæˆæ¶ˆæ¯
      pushMessage({
        role: 'agent',
        text: `âœ… ä»»åŠ¡è®¡åˆ’æ‰§è¡Œå®Œæˆï¼å…±å®Œæˆ ${allResults.length} ä¸ªæ­¥éª¤ã€‚`
      });
    }
    
    // æ¸…ç†æ‰§è¡Œå™¨
    setTodoExecutors(prev => {
      const { [activeId]: removed, ...rest } = prev;
      console.log('Todoå®Œæˆåæ¸…ç†æ‰§è¡Œå™¨ï¼Œå‰©ä½™:', Object.keys(rest));
      return rest;
    });
  }
  
  function handleBottomTodoPause(): void {
    const currentTodo = getCurrentTodo();
    if (currentTodo && activeId) {
      // æš‚åœæ‰§è¡Œå™¨
      const executor = todoExecutors[activeId];
      if (executor) {
        executor.pause();
      }
      
      const pausedTodo = { ...currentTodo, status: 'paused' as const };
      setCurrentTodo(pausedTodo);
      pushMessage({ 
        role: 'agent', 
        text: `â¸ï¸ ä»»åŠ¡æ‰§è¡Œå·²æš‚åœ` 
      });
    }
  }
  
  function handleBottomTodoClose(): void {
    setCurrentTodo(null);
    if (activeId) {
      setTodoExpanded(prev => ({ ...prev, [activeId]: false }));
      
      // æ¸…ç†æ‰§è¡Œå™¨
      console.log('handleBottomTodoClose: æ¸…ç†æ‰§è¡Œå™¨', activeId);
      setTodoExecutors(prev => {
        const { [activeId]: removed, ...rest } = prev;
        console.log('å…³é—­Todoåæ¸…ç†æ‰§è¡Œå™¨ï¼Œå‰©ä½™:', Object.keys(rest));
        return rest;
      });
    }
  }
  
  function handleBottomTodoToggleExpanded(): void {
    if (activeId) {
      setTodoExpanded(prev => ({ ...prev, [activeId]: !prev[activeId] }));
    }
  }




  function trimMessagesForMemory(messages: Message[]): Message[] {
    
    // è®¡ç®—è½®æ•°ï¼šä¸€è½® = ä¸€ä¸ªç”¨æˆ·æ¶ˆæ¯ + ä¸€ä¸ªagentå›å¤
    const rounds: Message[][] = [];
    let currentRound: Message[] = [];
    
    for (const message of messages) {
      currentRound.push(message);
      if (message.role === 'agent') {
        rounds.push([...currentRound]);
        currentRound = [];
      }
    }
    
    // å¦‚æœæœ€åè¿˜æœ‰æœªå®Œæˆçš„è½®æ¬¡ï¼ˆåªæœ‰ç”¨æˆ·æ¶ˆæ¯ï¼‰ï¼Œä¹Ÿä¿ç•™
    if (currentRound.length > 0) {
      rounds.push(currentRound);
    }
    
    // åªä¿ç•™æœ€è¿‘çš„Nè½®
    const recentRounds = rounds.slice(-memorySettings.maxRounds);
    return recentRounds.flat();
  }

  const active = getActive();
  const sortedConversations = React.useMemo(() => {
    return [...conversations].sort((a, b) => b.updatedAt - a.updatedAt);
  }, [conversations]);

  React.useEffect(() => {
    if (searchParams.get('new') === '1') {
      handleNewConversation();
      const url = new URL(window.location.href);
      url.searchParams.delete('new');
      navigate({ pathname: url.pathname, search: url.search }, { replace: true });
    }
  // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [searchParams]);

  return (
    <Stack direction="row" spacing={2} sx={{ height: 'calc(100vh - 120px)', minHeight: 0 }}>
        <Paper variant="outlined" sx={{ width: 280, p: 1, display: { xs: 'none', sm: 'block' }, flexShrink: 0, height: '100%', overflow: 'hidden' }}>
          <Stack spacing={1} sx={{ height: '100%' }}>
            <Button variant="text" color="inherit" startIcon={<AddIcon />} onClick={() => handleNewConversation()}>æ–°å»ºå¯¹è¯</Button>
            <Divider />
            <List dense disablePadding sx={{ flex: 1, overflow: 'auto' }}>
              {sortedConversations.map(c => (
                <ListItemButton key={c.id} selected={c.id === activeId} onClick={() => setActiveId(c.id)} sx={{ borderRadius: 1, mb: 0.5 }}>
                  <ListItemText
                    primary={<Typography variant="body2" fontWeight={600} noWrap title={c.title}>{c.title}</Typography>}
                    secondary={<Typography variant="caption" color="text.secondary">{new Date(c.updatedAt).toLocaleString()}</Typography>}
                  />
                  <IconButton size="small" onClick={(e) => { e.stopPropagation(); setMenuAnchor(e.currentTarget); setMenuConvId(c.id); }}>
                    <MoreVertIcon fontSize="small" />
                  </IconButton>
                </ListItemButton>
              ))}
              {sortedConversations.length === 0 && (
                <Box 
                  sx={{ 
                    display: 'flex', 
                    alignItems: 'center', 
                    justifyContent: 'center', 
                    height: '100%',
                    minHeight: '200px'
                  }}
                >
                  <Typography 
                    color="text.secondary" 
                    variant="body2" 
                    sx={{ 
                      textAlign: 'center',
                      opacity: 0.6
                    }}
                  >
                    æš‚æ— å¯¹è¯ï¼Œç‚¹å‡»"æ–°å»ºå¯¹è¯"å¼€å§‹
                  </Typography>
                </Box>
              )}
            </List>
          </Stack>
        </Paper>

        <Paper variant="outlined" sx={{ flex: 1, minHeight: 0, height: '100%', display: 'flex', flexDirection: 'column', backgroundColor: 'background.default', position: 'relative' }}>
          {active && (
            <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', p: 2, pb: 1, borderBottom: '1px solid', borderColor: 'divider' }}>
              <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                <Typography variant="h6" sx={{ fontWeight: 500 }}>{active.title}</Typography>
                {(() => {
                  const currentRounds = Math.floor(active.messages.length / 2);
                  const memoryRounds = memorySettings.maxRounds;
                  return currentRounds > memoryRounds ? (
                    <Typography variant="caption" sx={{ color: 'text.disabled', fontSize: '0.75rem' }}>
                      è®°å¿† {currentRounds}/{memoryRounds}
                    </Typography>
                  ) : null;
                })()}
              </Box>
              <Box sx={{ display: 'flex', gap: 0.5 }}>
                <IconButton 
                  size="small" 
                  onClick={() => setMemorySettingsOpen(true)}
                  sx={{ color: 'grey.600' }}
                  title="è®°å¿†è®¾ç½®"
                >
                  <PsychologyIcon fontSize="small" />
                </IconButton>
                <IconButton 
                  size="small" 
                  onClick={() => setRAGSettingsOpen(true)}
                  sx={{ color: ragSettings.enabled ? 'primary.main' : 'grey.600' }}
                  title="çŸ¥è¯†æ£€ç´¢"
                >
                  <SearchIcon fontSize="small" />
                </IconButton>
                {active.messages.length > 0 && (
                  <IconButton 
                    size="small" 
                    onClick={() => setClearChatOpen(true)}
                    sx={{ color: 'grey.600' }}
                    title="æ¸…é™¤èŠå¤©è®°å½•"
                  >
                    <DeleteIcon fontSize="small" />
                  </IconButton>
                )}
              </Box>
            </Box>
          )}
          
          <Box sx={{ flex: 1, minHeight: 0, overflow: 'auto', p: 2 }}>
            {!active || active.messages.length === 0 ? (
              <Box sx={{ 
                display: 'flex', 
                flexDirection: 'column', 
                alignItems: 'center', 
                justifyContent: 'center', 
                height: '100%',
                textAlign: 'center',
                gap: 3
              }}>
                <AutoAwesomeIcon sx={{ fontSize: 64, color: 'text.disabled' }} />
                <Typography variant="body1" sx={{ color: 'text.secondary' }}>
                  å—¨ï½æˆ‘æ˜¯ä½ çš„æ¸¸æˆå‘è¡Œå°åŠ©ç†ï¼æœ‰ä»€ä¹ˆæƒ³èŠçš„å—ï¼Ÿ
                </Typography>
                <Stack spacing={2} alignItems="center">
                  <Stack direction="row" spacing={2}>
                    <Button 
                      variant="outlined" 
                      size="small"
                      onClick={() => setInput('ç»™æˆ‘ä»Šæ—¥çš„çƒ­ç‚¹')}
                      sx={{ 
                        borderRadius: 2,
                        textTransform: 'none',
                        color: 'text.secondary',
                        borderColor: 'divider',
                        '&:hover': {
                          borderColor: 'primary.main',
                          backgroundColor: 'primary.50'
                        }
                      }}
                    >
                      ç»™æˆ‘ä»Šæ—¥çš„çƒ­ç‚¹
                    </Button>
                    <Button 
                      variant="outlined" 
                      size="small"
                      onClick={() => setInput('è®¾è®¡ä¸€ä¸ªç½‘é¡µæ´»åŠ¨')}
                      sx={{ 
                        borderRadius: 2,
                        textTransform: 'none',
                        color: 'text.secondary',
                        borderColor: 'divider',
                        '&:hover': {
                          borderColor: 'primary.main',
                          backgroundColor: 'primary.50'
                        }
                      }}
                    >
                      è®¾è®¡ä¸€ä¸ªç½‘é¡µæ´»åŠ¨
                    </Button>
                  </Stack>
                  <Stack direction="row" spacing={2}>
                    <Button 
                      variant="outlined" 
                      size="small"
                      onClick={() => setInput('è¿›è¡Œæ•°æ®åˆ†æ')}
                      sx={{ 
                        borderRadius: 2,
                        textTransform: 'none',
                        color: 'text.secondary',
                        borderColor: 'divider',
                        '&:hover': {
                          borderColor: 'primary.main',
                          backgroundColor: 'primary.50'
                        }
                      }}
                    >
                      è¿›è¡Œæ•°æ®åˆ†æ
                    </Button>
                    <Button 
                      variant="outlined" 
                      size="small"
                      onClick={() => setInput('æŸ¥è¯¢æ¸¸æˆé“å…·')}
                      sx={{ 
                        borderRadius: 2,
                        textTransform: 'none',
                        color: 'text.secondary',
                        borderColor: 'divider',
                        '&:hover': {
                          borderColor: 'primary.main',
                          backgroundColor: 'primary.50'
                        }
                      }}
                    >
                      æŸ¥è¯¢æ¸¸æˆé“å…·
                    </Button>
                  </Stack>
                </Stack>
              </Box>
            ) : (
              <Stack spacing={2}>
                {/* æ­£å¸¸çš„æ¶ˆæ¯æ¸²æŸ“ */}
                {(active.messages || []).map(m => {
                  const specialMessage = m as SpecialMessage;
                  const isCommandResult = specialMessage.type === 'command_result';
                  const isActionResult = specialMessage.type === 'action_result';
                  const isSpecialMessage = isCommandResult || isActionResult;
                  
                  return (
                    <Stack key={m.id} direction="row" spacing={2} justifyContent={m.role === 'user' ? 'flex-end' : 'flex-start'}>
                      {m.role === 'agent' && (
                        <Avatar sx={{ 
                          bgcolor: isCommandResult ? 'warning.main' : 
                                   isActionResult ? 'success.main' : 
                                   'primary.main',
                          color: 'white'
                        }}>
                          {isCommandResult ? 'âš¡' : isActionResult ? 'ğŸ”§' : 'A'}
                        </Avatar>
                      )}
                      <Box sx={{ maxWidth: '70%' }}>
                        <Typography variant="caption" color="text.secondary">
                          {m.role === 'agent' ? 
                            (isCommandResult ? 'æŒ‡ä»¤æ‰§è¡Œ' : 
                             isActionResult ? 'åŠ¨ä½œæ‰§è¡Œ' : 
                             'Agent') : 'æˆ‘'} Â· {new Date(m.createdAt).toLocaleTimeString()}
                          {specialMessage.metadata?.commandName && (
                            <Chip 
                              label={specialMessage.metadata.commandName} 
                              size="small" 
                              sx={{ ml: 1, fontSize: '0.75rem', height: 20 }}
                              color="warning"
                              variant="outlined"
                            />
                          )}
                          {specialMessage.metadata?.actionName && (
                            <Chip 
                              label={specialMessage.metadata.actionName} 
                              size="small" 
                              sx={{ ml: 1, fontSize: '0.75rem', height: 20 }}
                              color="success"
                              variant="outlined"
                            />
                          )}
                          {m.role === 'agent' && m.thinking && (
                            <Button size="small" sx={{ ml: 1 }} onClick={() => setExpandedThinking(prev => ({ ...prev, [m.id]: !prev[m.id] }))}>
                              {expandedThinking[m.id] ? 'æ”¶èµ·æ€è€ƒ' : 'å±•å¼€æ€è€ƒ'}
                            </Button>
                          )}
                        </Typography>
                        <Paper 
                          variant="outlined" 
                          sx={{ 
                            p: 1.25, 
                            mt: 0.5, 
                            backgroundColor: m.role === 'agent' ? 
                              (isCommandResult ? 'warning.50' : 
                               isActionResult ? 'success.50' : 
                               'background.paper') : 
                              'primary.main', 
                            color: m.role === 'agent' ? 'inherit' : 'primary.contrastText', 
                            borderRadius: 1,
                            borderColor: isCommandResult ? 'warning.main' : 
                                        isActionResult ? 'success.main' : 
                                        'divider',
                            borderWidth: isSpecialMessage ? 2 : 1
                          }}
                        >
                          <Typography whiteSpace="pre-wrap">{m.text}</Typography>
                          
                        {/* æ˜¾ç¤ºç”Ÿæˆçš„å›¾åƒ */}
                        {m.imageBase64 && (
                          <Box 
                            sx={{ 
                              mt: 2, 
                              position: 'relative',
                              display: 'inline-block',
                              '&:hover .zoom-button': {
                                opacity: 1
                              }
                            }}
                          >
                            <img
                              src={m.imageBase64}
                              alt="Generated image"
                              style={{
                                maxWidth: '400px',
                                height: 'auto',
                                borderRadius: '8px',
                                boxShadow: '0 2px 8px rgba(0,0,0,0.1)',
                                cursor: 'pointer'
                              }}
                              onClick={() => setImageModalOpen({ open: true, src: m.imageBase64! })}
                            />
                            <IconButton
                              className="zoom-button"
                              sx={{
                                position: 'absolute',
                                bottom: 8,
                                right: 8,
                                backgroundColor: 'rgba(0,0,0,0.6)',
                                color: 'white',
                                opacity: 0,
                                transition: 'opacity 0.2s',
                                '&:hover': {
                                  backgroundColor: 'rgba(0,0,0,0.8)'
                                }
                              }}
                              size="small"
                              onClick={() => setImageModalOpen({ open: true, src: m.imageBase64! })}
                            >
                              <ZoomInIcon fontSize="small" />
                            </IconButton>
                          </Box>
                        )}
                        </Paper>
                        
                        {/* æ‰§è¡Œç»“æœå±•ç¤º */}
                        {m.executionResults && m.executionResults.length > 0 && (
                          <Box sx={{ mt: 1 }}>
                            {m.executionResults.map((result, index) => (
                              <ActionResultDisplay
                                key={`${m.id}-result-${index}`}
                                result={result}
                                defaultExpanded={false}
                              />
                            ))}
                          </Box>
                        )}
                        {m.role === 'agent' && m.thinking && (
                          <Collapse in={Boolean(expandedThinking[m.id])}>
                            <Paper variant="outlined" sx={{ p: 1.25, mt: 1, bgcolor: 'background.paper', borderRadius: 2 }}>
                              <Typography variant="overline" color="text.secondary">æ€è€ƒè¿‡ç¨‹</Typography>
                              <Typography whiteSpace="pre-wrap" sx={{ mt: 0.5 }}>{m.thinking}</Typography>
                            </Paper>
                          </Collapse>
                        )}
                      </Box>
                      {m.role === 'user' && (
                        <Avatar sx={{ bgcolor: 'grey.300' }}>æˆ‘</Avatar>
                      )}
                    </Stack>
                  );
                })}
                <div ref={messagesEndRef} />
              </Stack>
            )}
          </Box>

          {/* åº•éƒ¨Todoé¢æ¿ - å·²ç¦ç”¨ */}
          {false && getCurrentTodo() && (
            <Box sx={{ m: 2, mb: 1 }}>
              <BottomTodoPanel
                todoList={getCurrentTodo()!}
                onStart={handleBottomTodoStart}
                onPause={handleBottomTodoPause}
                onClose={handleBottomTodoClose}
                onToggleExpanded={handleBottomTodoToggleExpanded}
                expanded={activeId ? todoExpanded[activeId] || false : false}
                onForceNext={handleForceNext}
                hasContextIssue={activeId ? hasContextIssue[activeId] || false : false}
              />
            </Box>
          )}

          {/* æŒ‡ä»¤é€‰æ‹©æ°”æ³¡ */}
          {selectedCommandId && (
            <Box sx={{ mx: 2, mb: 1 }}>
              <Chip
                label={`æŒ‡ä»¤: ${commands.find(cmd => cmd.id === selectedCommandId)?.name || 'æœªçŸ¥æŒ‡ä»¤'}`}
                onDelete={() => setSelectedCommandId('')}
                deleteIcon={<CloseIcon />}
                color="primary"
                variant="filled"
                size="small"
                sx={{
                  bgcolor: 'primary.100',
                  color: 'primary.800',
                  '& .MuiChip-deleteIcon': {
                    color: 'primary.600',
                    '&:hover': {
                      color: 'primary.800'
                    }
                  },
                  boxShadow: '0 2px 8px rgba(0,0,0,0.1)',
                  animation: 'fadeIn 0.3s ease-in-out',
                  '@keyframes fadeIn': {
                    from: { opacity: 0, transform: 'translateY(-10px)' },
                    to: { opacity: 1, transform: 'translateY(0)' }
                  }
                }}
              />
            </Box>
          )}

          <Paper 
            variant="outlined" 
            sx={{ 
              p: 1.5, 
              m: 2, 
              mt: 0, 
              display: 'flex', 
              gap: 1.5, 
              alignItems: 'center',
              borderRadius: 3,
              bgcolor: 'grey.25',
              border: '1px solid',
              borderColor: 'grey.200',
              boxShadow: '0 2px 12px rgba(0,0,0,0.04)',
              '&:hover': {
                borderColor: 'primary.200',
                boxShadow: '0 4px 20px rgba(0,0,0,0.08)'
              },
              '&:focus-within': {
                borderColor: 'primary.main',
                boxShadow: '0 0 0 3px rgba(25, 118, 210, 0.12)'
              }
            }}
          >
            {/* æŠ€èƒ½é€‰æ‹©æŒ‰é’® */}
            <IconButton 
              color={selectedSkill ? "primary" : "default"}
              aria-label="select skill" 
              onClick={() => setSkillDialogOpen(true)}
              sx={{ 
                flexShrink: 0,
                width: 40,
                height: 40,
                borderRadius: 2,
                bgcolor: selectedSkill ? 'primary.50' : 'grey.50',
                border: selectedSkill ? '1px solid' : '1px solid',
                borderColor: selectedSkill ? 'primary.200' : 'grey.200',
                color: selectedSkill ? 'primary.main' : 'grey.600',
                transition: 'all 0.2s ease-in-out',
                '&:hover': {
                  bgcolor: selectedSkill ? 'primary.100' : 'grey.100',
                  borderColor: selectedSkill ? 'primary.300' : 'grey.300',
                  transform: 'translateY(-1px)',
                  boxShadow: '0 4px 12px rgba(0,0,0,0.15)'
                }
              }}
              title="é€‰æ‹©æŠ€èƒ½"
            >
              <ExtensionIcon fontSize="small" />
            </IconButton>
            
            <Box sx={{ position: 'relative', flex: 1 }}>
              {/* æŠ€èƒ½æç¤ºè¦†ç›–å±‚ */}
              {selectedSkill && (
                <Box sx={{
                  position: 'absolute',
                  left: 12,
                  top: '50%',
                  transform: 'translateY(-50%)',
                  zIndex: 1,
                  display: 'flex',
                  alignItems: 'center',
                  pointerEvents: 'none',
                  padding: '4px 8px',
                  borderRadius: 1,
                  '&:hover': {
                    bgcolor: 'rgba(25, 118, 210, 0.04)',
                    '& .close-button': {
                      opacity: 1,
                      visibility: 'visible'
                    }
                  }
                }}>
                  <Typography variant="body2" sx={{ 
                    color: 'primary.main', 
                    fontWeight: 500,
                    fontSize: '0.95rem',
                    mr: 0.5,
                    pointerEvents: 'auto',
                    cursor: 'default'
                  }}>
                    {skills.find(s => s.id === selectedSkill)?.name}
                  </Typography>
                  <IconButton 
                    className="close-button"
                    size="small" 
                    onClick={() => setSelectedSkill(null)}
                    sx={{ 
                      width: 18, 
                      height: 18, 
                      color: 'primary.main',
                      opacity: 0,
                      visibility: 'hidden',
                      transition: 'all 0.2s ease-in-out',
                      pointerEvents: 'auto',
                      '&:hover': { 
                        bgcolor: 'primary.100',
                        opacity: 1,
                        visibility: 'visible'
                      }
                    }}
                  >
                    <CloseIcon sx={{ fontSize: 14 }} />
                  </IconButton>
                </Box>
              )}
              
              <TextField
                fullWidth
                placeholder={selectedSkill === 'image_generation' ? "æè¿°æ‚¨æƒ³è¦ç”Ÿæˆçš„å›¾åƒ..." : "è¾“å…¥æ¶ˆæ¯..."}
                value={input}
                onChange={e => setInput(e.target.value)}
                onKeyDown={e => {
                  if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    void handleSend();
                  }
                }}
                variant="standard"
                InputProps={{
                  disableUnderline: true,
                  sx: {
                    bgcolor: 'transparent',
                    fontSize: '0.95rem',
                    '& input': {
                      padding: selectedSkill ? '12px 16px 12px 100px' : '12px 16px',
                      borderRadius: 2,
                      bgcolor: 'white',
                      border: '1px solid',
                      borderColor: selectedSkill ? 'primary.200' : 'grey.200',
                      transition: 'all 0.2s ease-in-out',
                      '&:focus': {
                        borderColor: 'primary.main',
                        boxShadow: '0 0 0 3px rgba(25, 118, 210, 0.08)'
                      },
                      '&::placeholder': {
                        color: selectedSkill ? 'primary.600' : 'grey.500',
                        opacity: 1
                      }
                    }
                  }
                }}
              />
            </Box>
            <IconButton 
              color="primary" 
              aria-label="send" 
              onClick={() => void handleSend()}
              disabled={!input.trim()}
              sx={{
                flexShrink: 0,
                width: 44,
                height: 44,
                borderRadius: 2.5,
                bgcolor: input.trim() ? 'primary.main' : 'grey.200',
                color: input.trim() ? 'white' : 'grey.500',
                border: '1px solid',
                borderColor: input.trim() ? 'primary.main' : 'grey.300',
                transition: 'all 0.2s ease-in-out',
                '&:hover': {
                  bgcolor: input.trim() ? 'primary.dark' : 'grey.300',
                  transform: input.trim() ? 'translateY(-1px)' : 'none',
                  boxShadow: input.trim() ? '0 6px 20px rgba(25, 118, 210, 0.3)' : 'none'
                },
                '&:disabled': {
                  bgcolor: 'grey.200',
                  color: 'grey.400',
                  borderColor: 'grey.300'
                }
              }}
            >
              <SendIcon fontSize="small" />
            </IconButton>
          </Paper>

        </Paper>
      <Menu
        open={isMenuOpen}
        anchorEl={menuAnchor}
        onClose={() => { setMenuAnchor(null); setMenuConvId(null); }}
      >
        <MenuItem onClick={() => {
          const conv = conversations.find(c => c.id === menuConvId);
          setRenameValue(conv?.title ?? '');
          setRenameOpen(true);
          setMenuAnchor(null);
        }}>é‡å‘½å</MenuItem>
        <MenuItem onClick={() => { setDeleteOpen(true); setMenuAnchor(null); }}>åˆ é™¤</MenuItem>
      </Menu>

      <Dialog open={renameOpen} onClose={() => setRenameOpen(false)}>
        <DialogTitle>é‡å‘½åå¯¹è¯</DialogTitle>
        <DialogContent>
          <TextField autoFocus fullWidth value={renameValue} onChange={e => setRenameValue(e.target.value)} />
        </DialogContent>
        <DialogActions>
          <Button onClick={() => setRenameOpen(false)}>å–æ¶ˆ</Button>
          <Button variant="contained" onClick={() => { if (menuConvId) handleRenameConversation(menuConvId, renameValue.trim() || 'æœªå‘½åå¯¹è¯'); setRenameOpen(false); }}>ç¡®å®š</Button>
        </DialogActions>
      </Dialog>

      <Dialog open={deleteOpen} onClose={() => setDeleteOpen(false)}>
        <DialogTitle>åˆ é™¤å¯¹è¯</DialogTitle>
        <DialogContent>
          <Typography>æ­¤æ“ä½œå°†åˆ é™¤é€‰ä¸­çš„å¯¹è¯åŠå…¶æ¶ˆæ¯ï¼Œæ˜¯å¦ç»§ç»­ï¼Ÿ</Typography>
        </DialogContent>
        <DialogActions>
          <Button onClick={() => setDeleteOpen(false)}>å–æ¶ˆ</Button>
          <Button color="error" variant="contained" onClick={() => { if (menuConvId) handleDeleteConversation(menuConvId); setDeleteOpen(false); }}>åˆ é™¤</Button>
        </DialogActions>
      </Dialog>

      <Dialog open={clearChatOpen} onClose={() => setClearChatOpen(false)}>
        <DialogTitle>æ¸…é™¤èŠå¤©è®°å½•</DialogTitle>
        <DialogContent>
          <Typography>æ­¤æ“ä½œå°†æ¸…é™¤å½“å‰å¯¹è¯çš„æ‰€æœ‰æ¶ˆæ¯ï¼Œä½†ä¿ç•™å¯¹è¯æœ¬èº«ã€‚æ˜¯å¦ç»§ç»­ï¼Ÿ</Typography>
        </DialogContent>
        <DialogActions>
          <Button onClick={() => setClearChatOpen(false)}>å–æ¶ˆ</Button>
          <Button color="error" variant="contained" onClick={() => { handleClearCurrentChat(); setClearChatOpen(false); }}>æ¸…é™¤</Button>
        </DialogActions>
      </Dialog>

      <Dialog open={memorySettingsOpen} onClose={() => setMemorySettingsOpen(false)} maxWidth="sm" fullWidth>
        <DialogTitle>è®°å¿†è®¾ç½®</DialogTitle>
        <DialogContent>
          <Stack spacing={3} sx={{ mt: 1 }}>
            <Box>
              <Typography variant="subtitle2" sx={{ mb: 1 }}>èŠå¤©è®°å¿†è½®æ•°</Typography>
              <Typography variant="body2" color="text.secondary" sx={{ mb: 2 }}>
                æ§åˆ¶ AI èƒ½è®°ä½å¤šå°‘è½®å¯¹è¯å†å²ã€‚ä¸€è½®åŒ…å«ä¸€æ¬¡ç”¨æˆ·æé—®å’Œ AI å›ç­”ã€‚
              </Typography>
              <FormControl fullWidth>
                <InputLabel>è®°å¿†è½®æ•°</InputLabel>
                <Select
                  value={memorySettings.maxRounds}
                  label="è®°å¿†è½®æ•°"
                  onChange={(e) => setMemorySettings(prev => ({ ...prev, maxRounds: Number(e.target.value) }))}
                >
                  <MenuItem value={3}>3 è½®</MenuItem>
                  <MenuItem value={5}>5 è½®</MenuItem>
                  <MenuItem value={10}>10 è½®</MenuItem>
                  <MenuItem value={20}>20 è½®</MenuItem>
                  <MenuItem value={50}>50 è½®</MenuItem>
                  <MenuItem value={100}>100 è½®</MenuItem>
                </Select>
              </FormControl>
            </Box>
          </Stack>
        </DialogContent>
        <DialogActions>
          <Button onClick={() => setMemorySettingsOpen(false)}>å…³é—­</Button>
        </DialogActions>
      </Dialog>

      {/* RAG è®¾ç½®å¯¹è¯æ¡† */}
      <Dialog open={ragSettingsOpen} onClose={() => setRAGSettingsOpen(false)} maxWidth="sm" fullWidth>
        <DialogTitle>çŸ¥è¯†æ£€ç´¢è®¾ç½®</DialogTitle>
        <DialogContent>
          <Stack spacing={3} sx={{ mt: 1 }}>
            <Box>
              <Typography variant="subtitle2" sx={{ mb: 1 }}>å¯ç”¨ RAG æ£€ç´¢</Typography>
              <Typography variant="body2" color="text.secondary" sx={{ mb: 2 }}>
                å¼€å¯åï¼ŒAI ä¼šè‡ªåŠ¨æ£€ç´¢çŸ¥è¯†åº“ä¸­çš„ç›¸å…³ä¿¡æ¯æ¥å›ç­”é—®é¢˜ã€‚
              </Typography>
              <FormControl fullWidth>
                <InputLabel>æ£€ç´¢çŠ¶æ€</InputLabel>
                <Select
                  value={ragSettings.enabled ? 'enabled' : 'disabled'}
                  label="æ£€ç´¢çŠ¶æ€"
                  onChange={(e) => setRAGSettings(prev => ({ ...prev, enabled: e.target.value === 'enabled' }))}
                >
                  <MenuItem value="enabled">âœ… å¯ç”¨æ£€ç´¢</MenuItem>
                  <MenuItem value="disabled">âŒ ç¦ç”¨æ£€ç´¢</MenuItem>
                </Select>
              </FormControl>
            </Box>

            {ragSettings.enabled && (
              <Box>
                <Typography variant="subtitle2" sx={{ mb: 1 }}>æ£€ç´¢ç»“æœæ•°é‡</Typography>
                <Typography variant="body2" color="text.secondary" sx={{ mb: 2 }}>
                  æ§åˆ¶æ¯æ¬¡æ£€ç´¢è¿”å›çš„çŸ¥è¯†åº“ç‰‡æ®µæ•°é‡ã€‚æ›´å¤šç»“æœæä¾›æ›´å…¨é¢çš„ä¿¡æ¯ï¼Œä½†å¯èƒ½å½±å“å“åº”é€Ÿåº¦ã€‚
                </Typography>
                <FormControl fullWidth>
                  <InputLabel>ç»“æœæ•°é‡</InputLabel>
                  <Select
                    value={ragSettings.maxResults}
                    label="ç»“æœæ•°é‡"
                    onChange={(e) => setRAGSettings(prev => ({ ...prev, maxResults: Number(e.target.value) }))}
                  >
                    <MenuItem value={1}>1 ä¸ªç»“æœ</MenuItem>
                    <MenuItem value={2}>2 ä¸ªç»“æœ</MenuItem>
                    <MenuItem value={3}>3 ä¸ªç»“æœ</MenuItem>
                    <MenuItem value={5}>5 ä¸ªç»“æœ</MenuItem>
                  </Select>
                </FormControl>
              </Box>
            )}

            <Alert severity="info" sx={{ mt: 2 }}>
              <Typography variant="body2">
                ğŸ“š å½“å‰çŸ¥è¯†åº“çŠ¶æ€ï¼š{getKnowledgeSources().filter(s => s.status === 'active').length} ä¸ªæ¿€æ´»çš„çŸ¥è¯†æº
              </Typography>
            </Alert>
          </Stack>
        </DialogContent>
        <DialogActions>
          <Button onClick={() => setRAGSettingsOpen(false)}>å…³é—­</Button>
        </DialogActions>
      </Dialog>

      {/* æŒ‡ä»¤é€‰æ‹©å¯¹è¯æ¡† */}
      <Dialog open={commandDialogOpen} onClose={() => setCommandDialogOpen(false)} maxWidth="md" fullWidth>
        <DialogTitle>é€‰æ‹©æŒ‡ä»¤æ¨¡æ¿</DialogTitle>
        <DialogContent>
          <Stack spacing={2} sx={{ mt: 1 }}>
            {/* æœç´¢æ¡† */}
            <TextField
              fullWidth
              placeholder="æœç´¢æŒ‡ä»¤..."
              value={commandSearchText}
              onChange={(e) => setCommandSearchText(e.target.value)}
              InputProps={{
                startAdornment: <SearchIcon sx={{ mr: 1, color: 'text.secondary' }} />
              }}
            />

            {/* æŒ‡ä»¤åˆ—è¡¨ */}
            <Box sx={{ maxHeight: 400, overflow: 'auto' }}>
              {['personal', 'public'].map((category) => {
                const categoryCommands = commands
                  .filter(cmd => cmd.category === category)
                  .filter(cmd => 
                    !commandSearchText || 
                    cmd.name.toLowerCase().includes(commandSearchText.toLowerCase()) ||
                    cmd.description.toLowerCase().includes(commandSearchText.toLowerCase())
                  );

                if (categoryCommands.length === 0) return null;

                return (
                  <Box key={category} sx={{ mb: 2 }}>
                    <Typography variant="subtitle2" color="text.secondary" sx={{ mb: 1, px: 1 }}>
                      {category === 'personal' ? 'æˆ‘çš„æŒ‡ä»¤' : 'å…¬å¼€æŒ‡ä»¤'}
                    </Typography>
                    <Stack spacing={1}>
                      {categoryCommands.map((command) => (
                        <Paper
                          key={command.id}
                          variant="outlined"
                          sx={{
                            p: 2,
                            cursor: 'pointer',
                            border: selectedCommandId === command.id ? 2 : 1,
                            borderColor: selectedCommandId === command.id ? 'primary.main' : 'divider',
                            bgcolor: selectedCommandId === command.id ? 'primary.50' : 'transparent',
                            '&:hover': {
                              bgcolor: selectedCommandId === command.id ? 'primary.100' : 'grey.50'
                            }
                          }}
                          onClick={() => {
                            setSelectedCommandId(command.id);
                            setCommandDialogOpen(false);
                            setCommandSearchText('');
                          }}
                        >
                          <Typography variant="subtitle2" sx={{ fontWeight: 600, mb: 0.5 }}>
                            {command.name}
                          </Typography>
                          <Typography variant="body2" color="text.secondary" sx={{ mb: 1 }}>
                            {command.description}
                          </Typography>
                          <Typography variant="caption" color="text.secondary" sx={{ 
                            display: 'block',
                            whiteSpace: 'pre-line',
                            bgcolor: 'grey.50',
                            p: 1,
                            borderRadius: 1,
                            fontFamily: 'monospace'
                          }}>
                            {command.todoList.split('\n').slice(0, 3).join('\n')}
                            {command.todoList.split('\n').length > 3 && '\n...'}
                          </Typography>
                        </Paper>
                      ))}
                    </Stack>
                  </Box>
                );
              })}

              {commands.filter(cmd => 
                !commandSearchText || 
                cmd.name.toLowerCase().includes(commandSearchText.toLowerCase()) ||
                cmd.description.toLowerCase().includes(commandSearchText.toLowerCase())
              ).length === 0 && (
                <Box sx={{ textAlign: 'center', py: 4 }}>
                  <Typography color="text.secondary">
                    {commandSearchText ? 'æœªæ‰¾åˆ°åŒ¹é…çš„æŒ‡ä»¤' : 'æš‚æ— å¯ç”¨æŒ‡ä»¤'}
                  </Typography>
                </Box>
              )}
            </Box>
          </Stack>
        </DialogContent>
        <DialogActions>
          {selectedCommandId && (
            <Button 
              onClick={() => {
                setSelectedCommandId('');
              }}
              color="error"
            >
              æ¸…é™¤é€‰æ‹©
            </Button>
          )}
          <Button onClick={() => setCommandDialogOpen(false)}>å…³é—­</Button>
        </DialogActions>
      </Dialog>

      {/* æŠ€èƒ½é€‰æ‹©å¼¹çª— */}
      <Dialog
        open={skillDialogOpen}
        onClose={() => setSkillDialogOpen(false)}
        maxWidth="sm"
        fullWidth
      >
        <DialogTitle>é€‰æ‹©æŠ€èƒ½</DialogTitle>
        <DialogContent>
          <Stack spacing={2} sx={{ mt: 1 }}>
            {skills.map((skill) => (
              <Paper
                key={skill.id}
                variant="outlined"
                sx={{
                  p: 2,
                  cursor: 'pointer',
                  border: selectedSkill === skill.id ? 2 : 1,
                  borderColor: selectedSkill === skill.id ? 'primary.main' : 'divider',
                  bgcolor: selectedSkill === skill.id ? 'primary.50' : 'transparent',
                  transition: 'all 0.2s ease-in-out',
                  '&:hover': {
                    bgcolor: selectedSkill === skill.id ? 'primary.100' : 'grey.50',
                    transform: 'translateY(-1px)',
                    boxShadow: '0 4px 12px rgba(0,0,0,0.1)'
                  }
                }}
                onClick={() => {
                  setSelectedSkill(skill.id);
                  setSkillDialogOpen(false);
                }}
              >
                <Box sx={{ display: 'flex', alignItems: 'center', gap: 2 }}>
                  <ExtensionIcon sx={{ 
                    color: selectedSkill === skill.id ? 'primary.main' : 'grey.600',
                    fontSize: 24 
                  }} />
                  <Box>
                    <Typography variant="subtitle1" sx={{ fontWeight: 600, mb: 0.5 }}>
                      {skill.name}
                    </Typography>
                    <Typography variant="body2" color="text.secondary">
                      {skill.description}
                    </Typography>
                  </Box>
                </Box>
              </Paper>
            ))}
          </Stack>
        </DialogContent>
        <DialogActions>
          {selectedSkill && (
            <Button 
              onClick={() => setSelectedSkill(null)}
              color="error"
            >
              æ¸…é™¤é€‰æ‹©
            </Button>
          )}
          <Button onClick={() => setSkillDialogOpen(false)}>å…³é—­</Button>
        </DialogActions>
      </Dialog>

      {/* å›¾ç‰‡æ”¾å¤§å¼¹çª— */}
      <Dialog
        open={imageModalOpen.open}
        onClose={() => setImageModalOpen({ open: false, src: '' })}
        maxWidth="lg"
        fullWidth
      >
        <DialogContent sx={{ p: 1, textAlign: 'center' }}>
          {imageModalOpen.src && (
            <img
              src={imageModalOpen.src}
              alt="Generated image"
              style={{
                maxWidth: '100%',
                maxHeight: '80vh',
                height: 'auto',
                borderRadius: '8px'
              }}
            />
          )}
        </DialogContent>
        <DialogActions>
          <Button
            startIcon={<SaveIcon />}
            onClick={() => {
              const link = document.createElement('a');
              link.href = imageModalOpen.src;
              link.download = `generated-image-${Date.now()}.png`;
              document.body.appendChild(link);
              link.click();
              document.body.removeChild(link);
            }}
          >
            ä¿å­˜å›¾ç‰‡
          </Button>
          <Button onClick={() => setImageModalOpen({ open: false, src: '' })}>
            å…³é—­
          </Button>
        </DialogActions>
      </Dialog>
    </Stack>
  );
}


