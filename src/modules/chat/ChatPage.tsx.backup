import React from 'react';
import { Box, Paper, Stack, TextField, IconButton, Typography, Avatar, Button, List, ListItemButton, ListItemText, Menu, MenuItem, Dialog, DialogTitle, DialogContent, DialogActions, Collapse, Divider, Chip, Alert, FormControl, InputLabel, Select } from '@mui/material';
import AddIcon from '@mui/icons-material/Add';
import ZoomInIcon from '@mui/icons-material/ZoomIn';
import SaveIcon from '@mui/icons-material/Save';
import { useSearchParams, useNavigate } from 'react-router-dom';
import { streamOllamaChat, OllamaChatMessage } from '../../services/ollama';
import { getSettings, getAppSettings } from '../../services/settings';
import { backendApiService, ChatMessage as BackendChatMessage } from '../../services/backendApiService';
import { gptImageService, ImageGenerationResult } from '../../services/gptImageService';
import { actionExecutorService, ActionExecutionResult } from '../../services/actionExecutorService';
import { selectBestAction } from '../../services/actionLibrary';
import { splitThinking } from '../../utils/thinking';
import { searchKnowledgeBase, formatSearchResultsAsContext, getKnowledgeSources } from '../../services/knowledgeBase';
import { getCommands, CommandItem } from '../../services/commandService';
import BottomTodoPanel, { SimpleTodoList } from '../../components/BottomTodoPanel';
import ActionResultDisplay from '../../components/ActionResultDisplay';
import { 
  generateSimpleTodoWithLLM, 
  isMultiStepTask, 
  startTodoExecution, 
  completeCurrentAndStartNext,
  updateTodoItemStatus 
} from '../../services/simpleTodoGenerator';
import { createTodoExecutor, TodoExecutor, TodoStepResult } from '../../services/todoExecutionService';
import MoreVertIcon from '@mui/icons-material/MoreVert';
import SendIcon from '@mui/icons-material/Send';
import DeleteIcon from '@mui/icons-material/Delete';
import PsychologyIcon from '@mui/icons-material/Psychology';
import AutoAwesomeIcon from '@mui/icons-material/AutoAwesome';
import SearchIcon from '@mui/icons-material/Search';
import SmartToyIcon from '@mui/icons-material/SmartToy';
import PlaylistPlayIcon from '@mui/icons-material/PlaylistPlay';
import CloseIcon from '@mui/icons-material/Close';
import AutoFixHighIcon from '@mui/icons-material/AutoFixHigh';
import ExtensionIcon from '@mui/icons-material/Extension';

type Message = {
  id: string;
  role: 'user' | 'agent';
  text: string;
  createdAt: number;
  thinking?: string;
  executionResults?: TodoStepResult[]; // 附加的执行结果
  imageBase64?: string; // 生成的图像数据
  isImageGeneration?: boolean; // 标记是否为图像生成消息
};


type Conversation = {
  id: string;
  title: string;
  messages: Message[];
  createdAt: number;
  updatedAt: number;
};

const STORAGE_KEY = 'launchbox_conversations_v1';
const MEMORY_SETTINGS_KEY = 'launchbox_memory_settings_v1';
const RAG_SETTINGS_KEY = 'launchbox_rag_settings_v1';
const TODOS_STORAGE_KEY = 'launchbox_conversation_todos_v1';
const INPUTS_STORAGE_KEY = 'launchbox_conversation_inputs_v1';
const COMMANDS_STORAGE_KEY = 'launchbox_conversation_commands_v1';

// 内存缓存，用于保存当前会话的图像数据
const imageCache = new Map<string, string>();

// 检查localStorage使用情况
function getLocalStorageUsage(): { used: number; total: number; percentage: number } {
  let used = 0;
  for (const key in localStorage) {
    if (localStorage.hasOwnProperty(key)) {
      used += localStorage[key].length + key.length;
    }
  }
  
  // 大多数浏览器的localStorage限制是5MB
  const total = 5 * 1024 * 1024; // 5MB in bytes
  const percentage = (used / total) * 100;
  
  return { used, total, percentage };
}

type MemorySettings = {
  maxRounds: number; // 最大保留轮数，0表示无限制
};

type RAGSettings = {
  enabled: boolean;
  maxResults: number;
};


type SpecialMessage = Message & {
  type?: 'command_result' | 'action_result';
  metadata?: {
    commandName?: string;
    actionName?: string;
    actionType?: string;
    executionTime?: number;
    result?: any;
  };
};

const defaultMemorySettings: MemorySettings = {
  maxRounds: 10
};

const defaultRAGSettings: RAGSettings = {
  enabled: true,
  maxResults: 3
};

export default function ChatPage(): JSX.Element {
  const [searchParams] = useSearchParams();
  const navigate = useNavigate();
  const [conversations, setConversations] = React.useState<Conversation[]>(() => {
    const raw = localStorage.getItem(STORAGE_KEY);
    if (!raw) return [];
    
    const parsed = JSON.parse(raw) as Conversation[];
    // 清理旧的todoMessages字段
    return parsed.map(conv => ({
      id: conv.id,
      title: conv.title,
      messages: conv.messages || [],
      createdAt: conv.createdAt,
      updatedAt: conv.updatedAt
    }));
  });
  const [activeId, setActiveId] = React.useState<string | null>(() => conversations[0]?.id ?? null);
  const [conversationInputs, setConversationInputs] = React.useState<Record<string, string>>(() => {
    try {
      const raw = localStorage.getItem(INPUTS_STORAGE_KEY);
      return raw ? JSON.parse(raw) : {};
    } catch (error) {
      console.error('Failed to load conversation inputs:', error);
      return {};
    }
  });
  const [expandedThinking, setExpandedThinking] = React.useState<Record<string, boolean>>({});
  const messagesEndRef = React.useRef<HTMLDivElement>(null);
  
  // 自动滚动到最新消息
  const scrollToBottom = (smooth: boolean = true) => {
    messagesEndRef.current?.scrollIntoView({ behavior: smooth ? 'smooth' : 'instant' });
  };

  React.useEffect(() => {
    scrollToBottom();
  }, [getActive()?.messages]);

  // 当切换对话时，立即跳转到底部（不使用动画）
  React.useEffect(() => {
    if (activeId) {
      scrollToBottom(false); // 立即跳转，不使用滚动动画
    }
  }, [activeId]);
  
  // 获取当前对话的输入文本
  const input = activeId ? (conversationInputs[activeId] || '') : '';
  
  // 设置当前对话的输入文本
  const setInput = (value: string) => {
    if (activeId) {
      setConversationInputs(prev => ({
        ...prev,
        [activeId]: value
      }));
    }
  };
  
  
  // 底部简单Todo状态 - 按对话ID存储
  const [conversationTodos, setConversationTodos] = React.useState<Record<string, SimpleTodoList>>(() => {
    try {
      const raw = localStorage.getItem(TODOS_STORAGE_KEY);
      return raw ? JSON.parse(raw) : {};
    } catch (error) {
      console.error('Failed to load conversation todos:', error);
      return {};
    }
  });
  const [todoExpanded, setTodoExpanded] = React.useState<Record<string, boolean>>({});
  
  // Todo执行器状态
  const [todoExecutors, setTodoExecutors] = React.useState<Record<string, TodoExecutor>>({});
  
  // 上下文问题状态
  const [hasContextIssue, setHasContextIssue] = React.useState<Record<string, boolean>>({});
  const [imageModalOpen, setImageModalOpen] = React.useState<{ open: boolean; src: string }>({ open: false, src: '' });
  
  // 监听执行器状态变化
  React.useEffect(() => {
    console.log('todoExecutors状态变化:', Object.keys(todoExecutors));
  }, [todoExecutors]);
  const [menuAnchor, setMenuAnchor] = React.useState<null | HTMLElement>(null);
  const [menuConvId, setMenuConvId] = React.useState<string | null>(null);
  const isMenuOpen = Boolean(menuAnchor);
  const [renameOpen, setRenameOpen] = React.useState(false);
  const [renameValue, setRenameValue] = React.useState('');
  const [deleteOpen, setDeleteOpen] = React.useState(false);
  const [clearChatOpen, setClearChatOpen] = React.useState(false);
  const [memorySettingsOpen, setMemorySettingsOpen] = React.useState(false);
  const [ragSettingsOpen, setRAGSettingsOpen] = React.useState(false);
  const [memorySettings, setMemorySettings] = React.useState<MemorySettings>(() => {
    const raw = localStorage.getItem(MEMORY_SETTINGS_KEY);
    return raw ? (JSON.parse(raw) as MemorySettings) : defaultMemorySettings;
  });
  const [ragSettings, setRAGSettings] = React.useState<RAGSettings>(() => {
    const raw = localStorage.getItem(RAG_SETTINGS_KEY);
    return raw ? (JSON.parse(raw) as RAGSettings) : defaultRAGSettings;
  });
  
  // 指令相关状态
  const [commands, setCommands] = React.useState<CommandItem[]>([]);
  const [conversationCommands, setConversationCommands] = React.useState<Record<string, string>>(() => {
    try {
      const raw = localStorage.getItem(COMMANDS_STORAGE_KEY);
      return raw ? JSON.parse(raw) : {};
    } catch (error) {
      console.error('Failed to load conversation commands:', error);
      return {};
    }
  });
  const [commandDialogOpen, setCommandDialogOpen] = React.useState(false);
  const [commandSearchText, setCommandSearchText] = React.useState('');
  
  // 技能相关状态
  const [skillDialogOpen, setSkillDialogOpen] = React.useState<boolean>(false);
  const [selectedSkill, setSelectedSkill] = React.useState<string | null>(null);
  
  // 技能列表定义
  const skills = [
    { id: 'image_generation', name: '图像生成', description: '生成高质量图像' },
    // 可以在这里添加更多技能
  ];
  
  // 获取当前对话的选中指令ID
  const selectedCommandId = activeId ? (conversationCommands[activeId] || '') : '';
  
  // 设置当前对话的选中指令ID
  const setSelectedCommandId = (commandId: string) => {
    if (activeId) {
      setConversationCommands(prev => ({
        ...prev,
        [activeId]: commandId
      }));
    }
  };

  React.useEffect(() => {
    try {
      // 创建一个没有循环引用的conversations副本用于序列化
      const serializableConversations = conversations.map(conv => ({
        ...conv,
        messages: conv.messages.map(msg => ({
          id: msg.id,
          role: msg.role,
          text: msg.text,
          createdAt: msg.createdAt,
          thinking: msg.thinking,
          imageBase64: msg.imageBase64, // 确保图像数据被保存
          isImageGeneration: msg.isImageGeneration, // 确保图像生成标记被保存
          // 移除可能包含循环引用的executionResults中的reasoning
          executionResults: msg.executionResults?.map(result => ({
            ...result,
            reasoning: result.reasoning ? {
              shouldProceed: result.reasoning.shouldProceed,
              reasoning: result.reasoning.reasoning,
              waitingForData: result.reasoning.waitingForData,
              // 不包含contextualInfo以避免循环引用
            } : undefined
          }))
        }))
      }));
      
      const dataToSave = JSON.stringify(serializableConversations);
      localStorage.setItem(STORAGE_KEY, dataToSave);
    } catch (error) {
      console.warn('保存conversations到localStorage失败:', error);
      
      // 如果是存储空间不足，尝试清理旧数据后重试
      if (error instanceof Error && error.name === 'QuotaExceededError') {
        const usage = getLocalStorageUsage();
        console.warn(`localStorage空间不足，当前使用: ${(usage.used / 1024 / 1024).toFixed(2)}MB (${usage.percentage.toFixed(1)}%)`);
        console.warn('尝试清理旧数据...');
        try {
          // 清理旧的对话，只保留最近的3个
          const recentConversations = conversations
            .sort((a, b) => b.updatedAt - a.updatedAt)
            .slice(0, 3);
          
          const cleanedData = recentConversations.map(conv => ({
            ...conv,
            messages: conv.messages.map(msg => ({
              id: msg.id,
              role: msg.role,
              text: msg.text,
              createdAt: msg.createdAt,
              thinking: msg.thinking,
              // 对于图像消息，保留标记但移除base64数据以节省空间
              imageBase64: msg.imageBase64 ? '[图像数据已清理以节省存储空间]' : undefined,
              isImageGeneration: msg.isImageGeneration,
              executionResults: msg.executionResults?.map(result => ({
                ...result,
                reasoning: result.reasoning ? {
                  shouldProceed: result.reasoning.shouldProceed,
                  reasoning: result.reasoning.reasoning,
                  waitingForData: result.reasoning.waitingForData,
                } : undefined
              }))
            }))
          }));
          
          localStorage.setItem(STORAGE_KEY, JSON.stringify(cleanedData));
          console.warn('已清理localStorage数据，保留最近3个对话');
        } catch (retryError) {
          console.error('清理localStorage后仍然保存失败:', retryError);
          // 最后的降级方案：完全清空localStorage
          try {
            localStorage.removeItem(STORAGE_KEY);
            console.warn('已清空localStorage中的对话数据');
          } catch (clearError) {
            console.error('清空localStorage失败:', clearError);
          }
        }
      }
    }
  }, [conversations]);

  // 持久化 conversationTodos
  React.useEffect(() => {
    try {
      localStorage.setItem(TODOS_STORAGE_KEY, JSON.stringify(conversationTodos));
    } catch (error) {
      console.error('Failed to save conversation todos:', error);
    }
  }, [conversationTodos]);

  // 持久化 conversationInputs
  React.useEffect(() => {
    try {
      localStorage.setItem(INPUTS_STORAGE_KEY, JSON.stringify(conversationInputs));
    } catch (error) {
      console.error('Failed to save conversation inputs:', error);
    }
  }, [conversationInputs]);

  // 持久化 conversationCommands
  React.useEffect(() => {
    try {
      localStorage.setItem(COMMANDS_STORAGE_KEY, JSON.stringify(conversationCommands));
    } catch (error) {
      console.error('Failed to save conversation commands:', error);
    }
  }, [conversationCommands]);

  React.useEffect(() => {
    localStorage.setItem(MEMORY_SETTINGS_KEY, JSON.stringify(memorySettings));
  }, [memorySettings]);

  React.useEffect(() => {
    localStorage.setItem(RAG_SETTINGS_KEY, JSON.stringify(ragSettings));
  }, [ragSettings]);

  // 加载指令数据
  React.useEffect(() => {
    setCommands(getCommands());
  }, []);

  function generateId(): string {
    if (typeof crypto !== 'undefined' && 'randomUUID' in crypto) {
      return (crypto as Crypto).randomUUID();
    }
    return `msg_${Date.now()}_${Math.random().toString(36).slice(2, 8)}`;
  }

  function upsertConversation(updater: (prev: Conversation[]) => Conversation[]): void {
    setConversations(prev => updater(prev));
  }

  function getActive(): Conversation | undefined {
    const conversation = conversations.find(c => c.id === activeId);
    if (!conversation) return undefined;
    
    // 从内存缓存中恢复图像数据
    const messagesWithImages = conversation.messages.map(msg => {
      if (msg.isImageGeneration === false && !msg.imageBase64 && imageCache.has(msg.id)) {
        return {
          ...msg,
          imageBase64: imageCache.get(msg.id)
        };
      }
      return msg;
    });
    
    return {
      ...conversation,
      messages: messagesWithImages
    };
  }
  
  function getCurrentTodo(): SimpleTodoList | null {
    return activeId ? conversationTodos[activeId] || null : null;
  }
  
  function setCurrentTodo(todo: SimpleTodoList | null): void {
    if (activeId) {
      setConversationTodos(prev => {
        if (todo === null) {
          const { [activeId]: removed, ...rest } = prev;
          return rest;
        }
        return { ...prev, [activeId]: todo };
      });
    }
  }

  function pushMessage(partial: Omit<Message, 'id' | 'createdAt'>): void {
    const now = Date.now();
    upsertConversation(prev => prev.map(c => c.id === activeId ? {
      ...c,
      messages: [...c.messages, { id: generateId(), createdAt: now, ...partial }],
      updatedAt: now
    } : c));
  }

  // 处理图像生成（通过Action库）
  async function handleImageGeneration(message: string): Promise<void> {
    const prompt = gptImageService.extractImagePrompt(message);

    // 生成唯一ID
    const messageId = generateId();
    const now = Date.now();

    // 显示生成中的消息
    const generatingMessage: Message = {
      id: messageId,
      role: 'agent',
      text: '正在为您生成图像，请稍候...',
      createdAt: now,
      isImageGeneration: true
    };

    // 直接使用upsertConversation来添加消息，确保ID一致
    upsertConversation(prev => prev.map(c => c.id === activeId ? {
      ...c,
      messages: [...c.messages, generatingMessage],
      updatedAt: now
    } : c));

    try {
      // 通过Action执行服务调用图像生成
      const result = await actionExecutorService.executeImageGeneration(prompt, 1536, 1024);

      // 如果图像生成成功，将图像数据保存到内存缓存
      if (result.success && result.data?.image_base64) {
        imageCache.set(messageId, result.data.image_base64);
      }

      // 更新消息内容
      upsertConversation(prev => prev.map(conv => {
        if (conv.id === activeId) {
          return {
            ...conv,
            messages: conv.messages.map(msg =>
              msg.id === messageId
                ? {
                    ...msg,
                    text: result.success
                      ? "已为您生成图像"
                      : `图像生成失败：${result.error}`,
                    imageBase64: result.success ? result.data?.image_base64 : undefined,
                    isImageGeneration: false // 清除生成中标记
                  }
                : msg
            ),
            updatedAt: Date.now()
          };
        }
        return conv;
      }));

    } catch (error) {
      // 更新为错误消息
      upsertConversation(prev => prev.map(conv => {
        if (conv.id === activeId) {
          return {
            ...conv,
            messages: conv.messages.map(msg =>
              msg.id === messageId
                ? {
                    ...msg,
                    text: `图像生成失败：${error instanceof Error ? error.message : String(error)}`,
                    isImageGeneration: false // 清除生成中标记
                  }
                : msg
            ),
            updatedAt: Date.now()
          };
        }
        return conv;
      }));
    }
  }

  async function handleAIResponse(): Promise<void> {
    if (!activeId) {
      const firstMessage = getActive()?.messages?.[0]?.text;
      handleNewConversation(firstMessage?.slice(0, 12) || '新对话');
    }

    const currentMessages = getActive()?.messages ?? [];
    const lastUserMessage = currentMessages.filter(m => m.role === 'user').pop()?.text || '';
    
    // RAG检索（如果启用）
    let contextualPrompt = lastUserMessage;
    if (ragSettings.enabled) {
      try {
        const knowledgeSources = getKnowledgeSources();
        if (knowledgeSources.some(source => source.status === 'active')) {
          const searchResults = await searchKnowledgeBase(lastUserMessage, ragSettings.maxResults);
          if (searchResults.length > 0) {
            const context = formatSearchResultsAsContext(searchResults);
            contextualPrompt = `${context}\n\n${lastUserMessage}`;
          }
        }
      } catch (error) {
        console.error('RAG检索失败:', error);
      }
    }

    const appSettings = getAppSettings();
    const assistantId = generateId();
    const startTs = Date.now();
    
    // 创建助手消息
    upsertConversation(prev => prev.map(c => c.id === activeId ? {
      ...c,
      messages: [...c.messages, { id: assistantId, role: 'agent', text: '', createdAt: startTs }],
      updatedAt: startTs
    } : c));

    try {
      if (appSettings.useBackendApi) {
        // 使用后端OpenAI API
        const trimmedMessages = trimMessagesForMemory(currentMessages);
        const backendMessages: BackendChatMessage[] = trimmedMessages.map(m => ({
          role: m.role === 'agent' ? 'assistant' : 'user',
          content: m.text
        }));
        
        // 添加当前用户消息
        backendMessages.push({
          role: 'user',
          content: contextualPrompt
        });

        // 使用流式API
        await backendApiService.startStreamingChat(
          backendMessages,
          (chunk: string) => {
            // 处理流式响应块
            const now = Date.now();
            upsertConversation(prev => prev.map(c => {
              if (c.id !== activeId) return c;
              const nextMessages = c.messages.map(m => {
                if (m.id !== assistantId) return m;
                const merged = m.text + chunk;
                const { visible, thinking } = splitThinking(merged);
                return { ...m, text: visible, thinking };
              });
              return { ...c, messages: nextMessages, updatedAt: now };
            }));
          },
          () => {
            // 完成回调
            console.log('Backend streaming completed');
          },
          (error: string) => {
            // 错误回调
            console.error('Backend streaming error:', error);
            pushMessage({ role: 'agent', text: `❌ 后端API调用失败: ${error}` });
          }
        );
      } else {
        // 使用原来的Ollama
        const trimmedMessages = trimMessagesForMemory(currentMessages);
        const history: OllamaChatMessage[] = trimmedMessages.map(m => ({
          role: m.role === 'agent' ? 'assistant' : 'user',
          content: m.text
        }));

        for await (const chunk of streamOllamaChat([...history, { role: 'user', content: contextualPrompt }])) {
          const now = Date.now();
          upsertConversation(prev => prev.map(c => {
            if (c.id !== activeId) return c;
            const nextMessages = c.messages.map(m => {
              if (m.id !== assistantId) return m;
              const merged = m.text + chunk;
              const { visible, thinking } = splitThinking(merged);
              return { ...m, text: visible, thinking };
            });
            return { ...c, messages: nextMessages, updatedAt: now };
          }));
        }
      }
    } catch (e) {
      const err = e as Error;
      const serviceName = appSettings.useBackendApi ? 'Backend API' : 'Ollama';
      pushMessage({ role: 'agent', text: `❌ 调用 ${serviceName} 失败: ${err.message}` });
    }
  }

  function handleNewConversation(initialTitle?: string): void {
    const now = Date.now();
    const id = generateId();
    const newConv: Conversation = { id, title: initialTitle || '新对话', messages: [], createdAt: now, updatedAt: now };
    setConversations(prev => [newConv, ...prev]);
    setActiveId(id);
  }

  async function handleNewConversationAndSend(message: string): Promise<void> {
    const now = Date.now();
    const id = generateId();
    const newConv: Conversation = { id, title: '新对话', messages: [], createdAt: now, updatedAt: now };
    
    // 同步创建对话并设置为活跃
    setConversations(prev => [newConv, ...prev]);
    setActiveId(id);
    
    // 等待状态更新，然后发送消息
    // 使用 React 的批处理机制，在下一个事件循环中执行
    setTimeout(async () => {
      await handleIntelligentSend(message);
    }, 0);
  }

  function handleRenameConversation(id: string, title: string): void {
    upsertConversation(prev => prev.map(c => c.id === id ? { ...c, title, updatedAt: Date.now() } : c));
  }

  function handleDeleteConversation(id: string): void {
    setConversations(prev => {
      const updated = prev.filter(c => c.id !== id);
      // 如果删除的是当前活跃对话，需要切换到其他对话
      if (activeId === id) {
        setActiveId(updated[0]?.id ?? null);
      }
      return updated;
    });
    
    // 清除被删除对话的相关数据
    setConversationTodos(prev => {
      const { [id]: removed, ...rest } = prev;
      return rest;
    });
    
    setTodoExpanded(prev => {
      const { [id]: removed, ...rest } = prev;
      return rest;
    });
    
    setTodoExecutors(prev => {
      const { [id]: removed, ...rest } = prev;
      return rest;
    });
    
    // 清除输入框和指令选择状态
    setConversationInputs(prev => {
      const { [id]: removed, ...rest } = prev;
      return rest;
    });
    
    setConversationCommands(prev => {
      const { [id]: removed, ...rest } = prev;
      return rest;
    });
  }

  function handleClearCurrentChat(): void {
    if (!activeId) return;
    
    // 清除聊天记录
    setConversations(prev => prev.map(c => 
      c.id === activeId 
        ? { ...c, messages: [], updatedAt: Date.now() }
        : c
    ));
    
    // 清除思考过程展开状态
    setExpandedThinking({});
    
    // 清除当前对话的Todo数据
    setConversationTodos(prev => {
      const { [activeId]: removed, ...rest } = prev;
      return rest;
    });
    
    // 清除当前对话的Todo展开状态
    setTodoExpanded(prev => {
      const { [activeId]: removed, ...rest } = prev;
      return rest;
    });
    
    // 清除当前对话的Todo执行器
    console.log('handleClearCurrentChat: 清除执行器', activeId);
    setTodoExecutors(prev => {
      const { [activeId]: removed, ...rest } = prev;
      console.log('清除执行器后剩余:', Object.keys(rest));
      return rest;
    });
    
    // 清除当前对话的输入框和指令选择状态
    setConversationInputs(prev => {
      const { [activeId]: removed, ...rest } = prev;
      return rest;
    });
    
    setConversationCommands(prev => {
      const { [activeId]: removed, ...rest } = prev;
      return rest;
    });
  }

  async function handleSend(): Promise<void> {
    if (!input.trim()) return;
    
    const userMessage = input.trim();
    setInput('');
    
    // 如果没有活跃对话，创建一个新对话并发送消息
    if (!activeId) {
      handleNewConversationAndSend(userMessage);
      return;
    }
    
    // 统一处理所有输入
    await handleIntelligentSend(userMessage);
  }

  async function handleIntelligentSend(message: string): Promise<void> {
    pushMessage({ role: 'user', text: message });
    
    // 首先检查是否有待处理的用户输入任务
    const pendingUserInput = checkForPendingUserInput();
    if (pendingUserInput) {
      // 处理用户输入响应
      await handleUserInputResponse(pendingUserInput, message);
      return;
    }
    
        // 检查是否选中了图像生成技能，或者通过关键词检测到图像生成请求
        if (selectedSkill === 'image_generation') {
          await handleImageGeneration(message);
          return;
        }
        
        // 如果没有选中技能，则通过关键词检测
        const selectedAction = selectBestAction(message);
        if (selectedAction && selectedAction.type === '图像生成') {
          await handleImageGeneration(message);
          return;
        }
    
    // 检查是否选择了指令模板
    const selectedCommand = selectedCommandId ? commands.find(cmd => cmd.id === selectedCommandId) : null;
    
    // 如果选择了指令模板，或者是多步骤任务，则生成Todo - 已禁用TODO功能
    if (false && (selectedCommand || isMultiStepTask(message))) {
      // 显示固定的计划制定消息
      const templateInfo = selectedCommand ? `（基于指令模板：${selectedCommand.name}）` : '';
      pushMessage({ 
        role: 'agent', 
        text: `已经收到你的需求${templateInfo}，正在制定计划…` 
      });
      
      try {
        let enhancedMessage = message;
        
        if (selectedCommand) {
          enhancedMessage = `请按照以下指令模板制定详细的执行计划：

指令模板：${selectedCommand.name}
任务步骤：
${selectedCommand.todoList}

用户需求：${message}

请根据用户的具体需求，参考上述模板步骤，制定详细的执行计划。`;
        }
        
        const simpleTodo = await generateSimpleTodoWithLLM(enhancedMessage);
        if (simpleTodo && activeId) {
          console.log('生成Todo成功，activeId:', activeId);
          // 只设置Todo，保持draft状态，等待用户手动确认执行
          setCurrentTodo(simpleTodo);
          
          // 显示计划生成完成的消息
          const finalTemplateInfo = selectedCommand ? `（基于指令模板：${selectedCommand.name}）` : '';
          pushMessage({ 
            role: 'agent', 
            text: `📋 任务执行计划已生成${finalTemplateInfo}，共${simpleTodo.totalSteps}个步骤。请点击"开始执行"按钮来启动任务。` 
          });
          
          // 清除选中的指令
          setSelectedCommandId('');
        } else {
          console.error('生成Todo失败或activeId为空:', { simpleTodo: !!simpleTodo, activeId });
        }
      } catch (error) {
        console.error('生成简单Todo失败:', error);
        // 如果生成失败，继续正常AI回复
        await handleAIResponse();
      }
    } else {
      // 正常AI回复
      await handleAIResponse();
    }
  }
  
  // 检查是否有待处理的用户输入任务
  function checkForPendingUserInput(): string | null {
    const active = getActive();
    if (!active) return null;
    
    // 查找最后一条包含AWAITING_USER_INPUT的消息
    for (let i = active.messages.length - 1; i >= 0; i--) {
      const message = active.messages[i];
      if (message.executionResults) {
        for (const result of message.executionResults) {
          if (result.error && result.error.startsWith('AWAITING_USER_INPUT:')) {
            return result.error.split(':')[1]; // 返回stepId
          }
        }
      }
    }
    
    return null;
  }
  
  // 处理用户输入响应
  async function handleUserInputResponse(stepId: string, userResponse: string): Promise<void> {
    if (!activeId) {
      console.error('activeId为空，无法处理用户输入');
      return;
    }
    
    console.log('处理用户输入响应:', { stepId, userResponse, activeId });
    console.log('当前所有执行器:', Object.keys(todoExecutors));
    console.log('当前Todo状态:', getCurrentTodo());
    
    // 获取对应的执行器
    const executor = todoExecutors[activeId];
    console.log('找到的执行器:', !!executor);
    
    if (executor) {
      // 调用执行器的handleUserInput方法
      console.log('调用执行器的handleUserInput方法');
      await executor.handleUserInput(stepId, userResponse);
      console.log('执行器handleUserInput完成');
    } else {
      console.error('未找到对应的Todo执行器', { 
        activeId, 
        availableExecutors: Object.keys(todoExecutors),
        todoExecutorsCount: Object.keys(todoExecutors).length,
        currentTodo: !!getCurrentTodo()
      });
    }
  }
  
  // 强制继续下一步
  function handleForceNext(): void {
    const currentTodo = getCurrentTodo();
    if (currentTodo && activeId) {
      const executor = todoExecutors[activeId];
      if (executor) {
        // 清除上下文问题状态
        setHasContextIssue(prev => ({ ...prev, [activeId]: false }));
        
        // 强制执行下一步
        executor.forceNextStep().catch(error => {
          console.error('强制继续失败:', error);
          pushMessage({ 
            role: 'agent', 
            text: `❌ 强制继续失败: ${error.message}` 
          });
        });
        
        // 显示强制继续消息
        pushMessage({ 
          role: 'agent', 
          text: `🔄 强制继续执行，忽略上下文问题...` 
        });
      }
    }
  }

  // 底部Todo操作处理函数
  function handleBottomTodoStart(): void {
    const currentTodo = getCurrentTodo();
    if (currentTodo && activeId) {
      // 创建真实的Todo执行器
      const executor = createTodoExecutor(
        currentTodo,
        handleTodoStepProgress,
        handleTodoComplete
      );
      
      // 保存执行器
      setTodoExecutors(prev => ({ ...prev, [activeId]: executor }));
      
      // 更新Todo状态为运行中，并标记为用户已确认且已开始
      const startedTodo = { 
        ...startTodoExecution(currentTodo), 
        userConfirmed: true,
        hasStarted: true  // 标记为已开始，一旦设置就永远不会重置
      };
      setCurrentTodo(startedTodo);
      
      // 开始执行后自动收起Todo面板
      setTodoExpanded(prev => ({ ...prev, [activeId]: false }));
      
      // 显示开始执行消息
      pushMessage({ 
        role: 'agent', 
        text: `🚀 开始执行任务计划...\n\n正在执行第1步：${startedTodo.items[0]?.text}` 
      });
      
      // 开始真实执行
      executor.start().catch(error => {
        console.error('Todo执行失败:', error);
        pushMessage({ 
          role: 'agent', 
          text: `❌ 任务执行出错: ${error.message}` 
        });
      });
    }
  }
  
  // 处理Todo步骤进度
  function handleTodoStepProgress(result: TodoStepResult): void {
    if (!activeId) return;
    
    console.log('handleTodoStepProgress 开始:', {
      stepId: result.stepId,
      success: result.success,
      waitingForContext: result.waitingForContext,
      reasoning: result.reasoning?.reasoning,
      error: result.error,
      currentTodoStatus: getCurrentTodo()?.status,
      currentTodoUserConfirmed: getCurrentTodo()?.userConfirmed
    });
    
    // 检查是否是上下文问题
    if (!result.success && result.error === 'WAITING_FOR_CONTEXT') {
      // 设置上下文问题状态
      setHasContextIssue(prev => ({ ...prev, [activeId]: true }));
      
      // 显示推理结果和等待信息
      const contextMessage: Message = {
        id: generateId(),
        role: 'agent',
        text: `🧠 **任务推理分析**\n\n${result.reasoning?.reasoning}\n\n⚠️ **缺失信息**: ${result.reasoning?.waitingForData}\n\n💡 建议：您可以选择"继续执行"等待更多信息，或点击"强制继续"按钮忽略此问题直接执行。`,
        createdAt: Date.now(),
        executionResults: [result]
      };
      
      // 添加到对话中
      upsertConversation(prev => prev.map(c => c.id === activeId ? {
        ...c,
        messages: [...c.messages, contextMessage],
        updatedAt: Date.now()
      } : c));
      
      return;
    }
    
    // 检查是否是用户输入询问（部分成功状态）
    if (!result.success && result.error === 'WAITING_FOR_USER_INPUT' && result.executionResult?.result?.partialSuccess) {
      // 更新Todo状态为等待用户
      const currentTodo = getCurrentTodo();
      if (currentTodo) {
        const updatedTodo = updateTodoItemStatus(
          currentTodo, 
          result.stepId, 
          'waiting_user'
        );
        setCurrentTodo(updatedTodo);
      }
      
      // 直接显示询问消息
      const askMessage = result.executionResult.result.askMessage;
      const messageWithWaiting: Message = {
        id: generateId(),
        role: 'agent',
        text: askMessage,
        createdAt: Date.now(),
        executionResults: [{
          ...result,
          error: `AWAITING_USER_INPUT:${result.stepId}` // 特殊标记包含stepId
        }]
      };
      
      // 添加到对话中
      upsertConversation(prev => prev.map(c => c.id === activeId ? {
        ...c,
        messages: [...c.messages, messageWithWaiting],
        updatedAt: Date.now()
      } : c));
      
      return;
    }
    
    // 检查是否是LLM任务
    if (result.success && result.executionResult?.result?.isLLMTask) {
      console.log('🎯 处理LLM任务成功结果:', {
        stepId: result.stepId,
        stepText: result.stepText,
        isLLMTask: result.executionResult?.result?.isLLMTask,
        method: result.executionResult?.result?.method
      });
      
      // 更新Todo状态为完成
      const currentTodo = getCurrentTodo();
      if (currentTodo) {
        console.log('📝 更新TODO状态前:', {
          currentStep: currentTodo.currentStep,
          totalSteps: currentTodo.totalSteps,
          status: currentTodo.status,
          items: currentTodo.items.map(i => ({ id: i.id, text: i.text, status: i.status }))
        });
        
        const updatedTodo = updateTodoItemStatus(
          currentTodo, 
          result.stepId, 
          'completed'
        );
        
        console.log('📝 更新TODO状态后:', {
          currentStep: updatedTodo.currentStep,
          totalSteps: updatedTodo.totalSteps,
          status: updatedTodo.status,
          items: updatedTodo.items.map(i => ({ id: i.id, text: i.text, status: i.status }))
        });
        
        setCurrentTodo(updatedTodo);
      }
      
      // 直接显示LLM处理结果作为消息
      const llmResponse = result.executionResult.result.llmResponse;
      const messageWithResult: Message = {
        id: generateId(),
        role: 'agent',
        text: llmResponse,
        createdAt: Date.now(),
        executionResults: [result] // 简化的执行结果，只显示标题
      };
      
      // 添加到对话中
      upsertConversation(prev => prev.map(c => c.id === activeId ? {
        ...c,
        messages: [...c.messages, messageWithResult],
        updatedAt: Date.now()
      } : c));
      
      return;
    }
    
    // 处理其他类型的任务（action类型）
    const currentTodo = getCurrentTodo();
    if (currentTodo) {
      const updatedTodo = updateTodoItemStatus(
        currentTodo, 
        result.stepId, 
        result.success ? 'completed' : 'failed'
      );
      setCurrentTodo(updatedTodo);
    }
    
    // 使用LLM处理执行结果并生成用户回复
    generateLLMResponseForResult(result);
  }
  
  
  // 使用LLM处理执行结果生成用户回复
  async function generateLLMResponseForResult(result: TodoStepResult): Promise<void> {
    try {
      // 构建给LLM的提示词
      const prompt = buildResultPrompt(result);
      
      // 调用LLM生成回复
      const messages: OllamaChatMessage[] = [
        { role: 'user', content: prompt }
      ];
      
      let llmResponse = '';
      const stream = streamOllamaChat(messages);
      
      for await (const chunk of stream) {
        llmResponse += chunk;
      }
      
      // 创建包含执行结果的消息
      const messageWithResult: Message = {
        id: generateId(),
        role: 'agent',
        text: llmResponse.trim(),
        createdAt: Date.now(),
        executionResults: [result] // 附加执行结果
      };
      
      // 添加到对话中
      upsertConversation(prev => prev.map(c => c.id === activeId ? {
        ...c,
        messages: [...c.messages, messageWithResult],
        updatedAt: Date.now()
      } : c));
      
    } catch (error) {
      console.error('LLM处理执行结果失败:', error);
      
      // 降级处理：直接显示简单的执行结果
      const fallbackText = result.success 
        ? `✅ 步骤完成：${result.stepText}`
        : `❌ 步骤失败：${result.stepText}\n\n错误：${result.error}`;
      
      pushMessage({ 
        role: 'agent', 
        text: fallbackText,
        executionResults: [result]
      });
    }
  }
  
  // 构建给LLM的结果处理提示词
  function buildResultPrompt(result: TodoStepResult): string {
    let prompt = `你是一个智能助手。用户刚刚执行了一个任务步骤，请根据执行结果为用户生成一个友好、简洁的回复。

任务步骤: ${result.stepText}
执行状态: ${result.success ? '成功' : '失败'}
执行时间: ${result.executionTime}ms`;

    if (result.actionUsed) {
      prompt += `\n使用工具: ${result.actionUsed.name} (${result.actionUsed.type})`;
    }

    if (result.success && result.executionResult?.result) {
      const resultData = result.executionResult.result;
      prompt += `\n\n执行结果:\n`;
      
      if (typeof resultData === 'object') {
        if (resultData.answer !== undefined) {
          prompt += `计算结果: ${resultData.answer}`;
        } else if (resultData.response) {
          prompt += resultData.response;
        } else if (resultData.processed) {
          prompt += `处理结果: ${resultData.processed}`;
        } else if (resultData.wordCount !== undefined) {
          prompt += `文本统计 - 单词: ${resultData.wordCount}, 字符: ${resultData.characterCount}`;
        } else {
          prompt += JSON.stringify(resultData, null, 2);
        }
      } else {
        prompt += String(resultData);
      }
    } else if (!result.success) {
      prompt += `\n\n错误信息: ${result.error}`;
    }

    prompt += `\n\n请生成一个简洁、友好的回复，向用户说明执行结果。不要重复显示技术细节，重点是结果的含义和价值。回复应该在50字以内。`;

    return prompt;
  }
  
  // 处理Todo完成
  function handleTodoComplete(allResults: TodoStepResult[]): void {
    if (!activeId) return;
    
    console.log('handleTodoComplete: 清理执行器', activeId, '结果数量:', allResults.length);
    
    // 更新TODO的最终状态为完成
    const currentTodo = getCurrentTodo();
    if (currentTodo) {
      console.log('📋 TODO执行完成，更新最终状态:', {
        currentStatus: currentTodo.status,
        currentStep: currentTodo.currentStep,
        totalSteps: currentTodo.totalSteps,
        allResultsSuccess: allResults.every(r => r.success)
      });
      
      // 将整个TODO标记为完成
      const completedTodo = {
        ...currentTodo,
        status: 'completed' as const,
        currentStep: currentTodo.totalSteps // 设置为总步数表示全部完成
      };
      
      setCurrentTodo(completedTodo);
      
      // 显示完成消息
      pushMessage({
        role: 'agent',
        text: `✅ 任务计划执行完成！共完成 ${allResults.length} 个步骤。`
      });
    }
    
    // 清理执行器
    setTodoExecutors(prev => {
      const { [activeId]: removed, ...rest } = prev;
      console.log('Todo完成后清理执行器，剩余:', Object.keys(rest));
      return rest;
    });
  }
  
  function handleBottomTodoPause(): void {
    const currentTodo = getCurrentTodo();
    if (currentTodo && activeId) {
      // 暂停执行器
      const executor = todoExecutors[activeId];
      if (executor) {
        executor.pause();
      }
      
      const pausedTodo = { ...currentTodo, status: 'paused' as const };
      setCurrentTodo(pausedTodo);
      pushMessage({ 
        role: 'agent', 
        text: `⏸️ 任务执行已暂停` 
      });
    }
  }
  
  function handleBottomTodoClose(): void {
    setCurrentTodo(null);
    if (activeId) {
      setTodoExpanded(prev => ({ ...prev, [activeId]: false }));
      
      // 清理执行器
      console.log('handleBottomTodoClose: 清理执行器', activeId);
      setTodoExecutors(prev => {
        const { [activeId]: removed, ...rest } = prev;
        console.log('关闭Todo后清理执行器，剩余:', Object.keys(rest));
        return rest;
      });
    }
  }
  
  function handleBottomTodoToggleExpanded(): void {
    if (activeId) {
      setTodoExpanded(prev => ({ ...prev, [activeId]: !prev[activeId] }));
    }
  }




  function trimMessagesForMemory(messages: Message[]): Message[] {
    
    // 计算轮数：一轮 = 一个用户消息 + 一个agent回复
    const rounds: Message[][] = [];
    let currentRound: Message[] = [];
    
    for (const message of messages) {
      currentRound.push(message);
      if (message.role === 'agent') {
        rounds.push([...currentRound]);
        currentRound = [];
      }
    }
    
    // 如果最后还有未完成的轮次（只有用户消息），也保留
    if (currentRound.length > 0) {
      rounds.push(currentRound);
    }
    
    // 只保留最近的N轮
    const recentRounds = rounds.slice(-memorySettings.maxRounds);
    return recentRounds.flat();
  }

  const active = getActive();
  const sortedConversations = React.useMemo(() => {
    return [...conversations].sort((a, b) => b.updatedAt - a.updatedAt);
  }, [conversations]);

  React.useEffect(() => {
    if (searchParams.get('new') === '1') {
      handleNewConversation();
      const url = new URL(window.location.href);
      url.searchParams.delete('new');
      navigate({ pathname: url.pathname, search: url.search }, { replace: true });
    }
  // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [searchParams]);

  return (
    <Stack direction="row" spacing={2} sx={{ height: 'calc(100vh - 120px)', minHeight: 0 }}>
        <Paper variant="outlined" sx={{ width: 280, p: 1, display: { xs: 'none', sm: 'block' }, flexShrink: 0, height: '100%', overflow: 'hidden' }}>
          <Stack spacing={1} sx={{ height: '100%' }}>
            <Button variant="text" color="inherit" startIcon={<AddIcon />} onClick={() => handleNewConversation()}>新建对话</Button>
            <Divider />
            <List dense disablePadding sx={{ flex: 1, overflow: 'auto' }}>
              {sortedConversations.map(c => (
                <ListItemButton key={c.id} selected={c.id === activeId} onClick={() => setActiveId(c.id)} sx={{ borderRadius: 1, mb: 0.5 }}>
                  <ListItemText
                    primary={<Typography variant="body2" fontWeight={600} noWrap title={c.title}>{c.title}</Typography>}
                    secondary={<Typography variant="caption" color="text.secondary">{new Date(c.updatedAt).toLocaleString()}</Typography>}
                  />
                  <IconButton size="small" onClick={(e) => { e.stopPropagation(); setMenuAnchor(e.currentTarget); setMenuConvId(c.id); }}>
                    <MoreVertIcon fontSize="small" />
                  </IconButton>
                </ListItemButton>
              ))}
              {sortedConversations.length === 0 && (
                <Box 
                  sx={{ 
                    display: 'flex', 
                    alignItems: 'center', 
                    justifyContent: 'center', 
                    height: '100%',
                    minHeight: '200px'
                  }}
                >
                  <Typography 
                    color="text.secondary" 
                    variant="body2" 
                    sx={{ 
                      textAlign: 'center',
                      opacity: 0.6
                    }}
                  >
                    暂无对话，点击"新建对话"开始
                  </Typography>
                </Box>
              )}
            </List>
          </Stack>
        </Paper>

        <Paper variant="outlined" sx={{ flex: 1, minHeight: 0, height: '100%', display: 'flex', flexDirection: 'column', backgroundColor: 'background.default', position: 'relative' }}>
          {active && (
            <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', p: 2, pb: 1, borderBottom: '1px solid', borderColor: 'divider' }}>
              <Box sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>
                <Typography variant="h6" sx={{ fontWeight: 500 }}>{active.title}</Typography>
                {(() => {
                  const currentRounds = Math.floor(active.messages.length / 2);
                  const memoryRounds = memorySettings.maxRounds;
                  return currentRounds > memoryRounds ? (
                    <Typography variant="caption" sx={{ color: 'text.disabled', fontSize: '0.75rem' }}>
                      记忆 {currentRounds}/{memoryRounds}
                    </Typography>
                  ) : null;
                })()}
              </Box>
              <Box sx={{ display: 'flex', gap: 0.5 }}>
                <IconButton 
                  size="small" 
                  onClick={() => setMemorySettingsOpen(true)}
                  sx={{ color: 'grey.600' }}
                  title="记忆设置"
                >
                  <PsychologyIcon fontSize="small" />
                </IconButton>
                <IconButton 
                  size="small" 
                  onClick={() => setRAGSettingsOpen(true)}
                  sx={{ color: ragSettings.enabled ? 'primary.main' : 'grey.600' }}
                  title="知识检索"
                >
                  <SearchIcon fontSize="small" />
                </IconButton>
                {active.messages.length > 0 && (
                  <IconButton 
                    size="small" 
                    onClick={() => setClearChatOpen(true)}
                    sx={{ color: 'grey.600' }}
                    title="清除聊天记录"
                  >
                    <DeleteIcon fontSize="small" />
                  </IconButton>
                )}
              </Box>
            </Box>
          )}
          
          <Box sx={{ flex: 1, minHeight: 0, overflow: 'auto', p: 2 }}>
            {!active || active.messages.length === 0 ? (
              <Box sx={{ 
                display: 'flex', 
                flexDirection: 'column', 
                alignItems: 'center', 
                justifyContent: 'center', 
                height: '100%',
                textAlign: 'center',
                gap: 3
              }}>
                <AutoAwesomeIcon sx={{ fontSize: 64, color: 'text.disabled' }} />
                <Typography variant="body1" sx={{ color: 'text.secondary' }}>
                  嗨～我是你的游戏发行小助理！有什么想聊的吗？
                </Typography>
                <Stack spacing={2} alignItems="center">
                  <Stack direction="row" spacing={2}>
                    <Button 
                      variant="outlined" 
                      size="small"
                      onClick={() => setInput('给我今日的热点')}
                      sx={{ 
                        borderRadius: 2,
                        textTransform: 'none',
                        color: 'text.secondary',
                        borderColor: 'divider',
                        '&:hover': {
                          borderColor: 'primary.main',
                          backgroundColor: 'primary.50'
                        }
                      }}
                    >
                      给我今日的热点
                    </Button>
                    <Button 
                      variant="outlined" 
                      size="small"
                      onClick={() => setInput('设计一个网页活动')}
                      sx={{ 
                        borderRadius: 2,
                        textTransform: 'none',
                        color: 'text.secondary',
                        borderColor: 'divider',
                        '&:hover': {
                          borderColor: 'primary.main',
                          backgroundColor: 'primary.50'
                        }
                      }}
                    >
                      设计一个网页活动
                    </Button>
                  </Stack>
                  <Stack direction="row" spacing={2}>
                    <Button 
                      variant="outlined" 
                      size="small"
                      onClick={() => setInput('进行数据分析')}
                      sx={{ 
                        borderRadius: 2,
                        textTransform: 'none',
                        color: 'text.secondary',
                        borderColor: 'divider',
                        '&:hover': {
                          borderColor: 'primary.main',
                          backgroundColor: 'primary.50'
                        }
                      }}
                    >
                      进行数据分析
                    </Button>
                    <Button 
                      variant="outlined" 
                      size="small"
                      onClick={() => setInput('查询游戏道具')}
                      sx={{ 
                        borderRadius: 2,
                        textTransform: 'none',
                        color: 'text.secondary',
                        borderColor: 'divider',
                        '&:hover': {
                          borderColor: 'primary.main',
                          backgroundColor: 'primary.50'
                        }
                      }}
                    >
                      查询游戏道具
                    </Button>
                  </Stack>
                </Stack>
              </Box>
            ) : (
              <Stack spacing={2}>
                {/* 正常的消息渲染 */}
                {(active.messages || []).map(m => {
                  const specialMessage = m as SpecialMessage;
                  const isCommandResult = specialMessage.type === 'command_result';
                  const isActionResult = specialMessage.type === 'action_result';
                  const isSpecialMessage = isCommandResult || isActionResult;
                  
                  return (
                    <Stack key={m.id} direction="row" spacing={2} justifyContent={m.role === 'user' ? 'flex-end' : 'flex-start'}>
                      {m.role === 'agent' && (
                        <Avatar sx={{ 
                          bgcolor: isCommandResult ? 'warning.main' : 
                                   isActionResult ? 'success.main' : 
                                   'primary.main',
                          color: 'white'
                        }}>
                          {isCommandResult ? '⚡' : isActionResult ? '🔧' : 'A'}
                        </Avatar>
                      )}
                      <Box sx={{ maxWidth: '70%' }}>
                        <Typography variant="caption" color="text.secondary">
                          {m.role === 'agent' ? 
                            (isCommandResult ? '指令执行' : 
                             isActionResult ? '动作执行' : 
                             'Agent') : '我'} · {new Date(m.createdAt).toLocaleTimeString()}
                          {specialMessage.metadata?.commandName && (
                            <Chip 
                              label={specialMessage.metadata.commandName} 
                              size="small" 
                              sx={{ ml: 1, fontSize: '0.75rem', height: 20 }}
                              color="warning"
                              variant="outlined"
                            />
                          )}
                          {specialMessage.metadata?.actionName && (
                            <Chip 
                              label={specialMessage.metadata.actionName} 
                              size="small" 
                              sx={{ ml: 1, fontSize: '0.75rem', height: 20 }}
                              color="success"
                              variant="outlined"
                            />
                          )}
                          {m.role === 'agent' && m.thinking && (
                            <Button size="small" sx={{ ml: 1 }} onClick={() => setExpandedThinking(prev => ({ ...prev, [m.id]: !prev[m.id] }))}>
                              {expandedThinking[m.id] ? '收起思考' : '展开思考'}
                            </Button>
                          )}
                        </Typography>
                        <Paper 
                          variant="outlined" 
                          sx={{ 
                            p: 1.25, 
                            mt: 0.5, 
                            backgroundColor: m.role === 'agent' ? 
                              (isCommandResult ? 'warning.50' : 
                               isActionResult ? 'success.50' : 
                               'background.paper') : 
                              'primary.main', 
                            color: m.role === 'agent' ? 'inherit' : 'primary.contrastText', 
                            borderRadius: 1,
                            borderColor: isCommandResult ? 'warning.main' : 
                                        isActionResult ? 'success.main' : 
                                        'divider',
                            borderWidth: isSpecialMessage ? 2 : 1
                          }}
                        >
                          <Typography whiteSpace="pre-wrap">{m.text}</Typography>
                          
                        {/* 显示生成的图像 */}
                        {m.imageBase64 && (
                          <Box 
                            sx={{ 
                              mt: 2, 
                              position: 'relative',
                              display: 'inline-block',
                              '&:hover .zoom-button': {
                                opacity: 1
                              }
                            }}
                          >
                            <img
                              src={m.imageBase64}
                              alt="Generated image"
                              style={{
                                maxWidth: '400px',
                                height: 'auto',
                                borderRadius: '8px',
                                boxShadow: '0 2px 8px rgba(0,0,0,0.1)',
                                cursor: 'pointer'
                              }}
                              onClick={() => setImageModalOpen({ open: true, src: m.imageBase64! })}
                            />
                            <IconButton
                              className="zoom-button"
                              sx={{
                                position: 'absolute',
                                bottom: 8,
                                right: 8,
                                backgroundColor: 'rgba(0,0,0,0.6)',
                                color: 'white',
                                opacity: 0,
                                transition: 'opacity 0.2s',
                                '&:hover': {
                                  backgroundColor: 'rgba(0,0,0,0.8)'
                                }
                              }}
                              size="small"
                              onClick={() => setImageModalOpen({ open: true, src: m.imageBase64! })}
                            >
                              <ZoomInIcon fontSize="small" />
                            </IconButton>
                          </Box>
                        )}
                        </Paper>
                        
                        {/* 执行结果展示 */}
                        {m.executionResults && m.executionResults.length > 0 && (
                          <Box sx={{ mt: 1 }}>
                            {m.executionResults.map((result, index) => (
                              <ActionResultDisplay
                                key={`${m.id}-result-${index}`}
                                result={result}
                                defaultExpanded={false}
                              />
                            ))}
                          </Box>
                        )}
                        {m.role === 'agent' && m.thinking && (
                          <Collapse in={Boolean(expandedThinking[m.id])}>
                            <Paper variant="outlined" sx={{ p: 1.25, mt: 1, bgcolor: 'background.paper', borderRadius: 2 }}>
                              <Typography variant="overline" color="text.secondary">思考过程</Typography>
                              <Typography whiteSpace="pre-wrap" sx={{ mt: 0.5 }}>{m.thinking}</Typography>
                            </Paper>
                          </Collapse>
                        )}
                      </Box>
                      {m.role === 'user' && (
                        <Avatar sx={{ bgcolor: 'grey.300' }}>我</Avatar>
                      )}
                    </Stack>
                  );
                })}
                <div ref={messagesEndRef} />
              </Stack>
            )}
          </Box>

          {/* 底部Todo面板 - 已禁用 */}
          {false && getCurrentTodo() && (
            <Box sx={{ m: 2, mb: 1 }}>
              <BottomTodoPanel
                todoList={getCurrentTodo()!}
                onStart={handleBottomTodoStart}
                onPause={handleBottomTodoPause}
                onClose={handleBottomTodoClose}
                onToggleExpanded={handleBottomTodoToggleExpanded}
                expanded={activeId ? todoExpanded[activeId] || false : false}
                onForceNext={handleForceNext}
                hasContextIssue={activeId ? hasContextIssue[activeId] || false : false}
              />
            </Box>
          )}

          {/* 指令选择气泡 */}
          {selectedCommandId && (
            <Box sx={{ mx: 2, mb: 1 }}>
              <Chip
                label={`指令: ${commands.find(cmd => cmd.id === selectedCommandId)?.name || '未知指令'}`}
                onDelete={() => setSelectedCommandId('')}
                deleteIcon={<CloseIcon />}
                color="primary"
                variant="filled"
                size="small"
                sx={{
                  bgcolor: 'primary.100',
                  color: 'primary.800',
                  '& .MuiChip-deleteIcon': {
                    color: 'primary.600',
                    '&:hover': {
                      color: 'primary.800'
                    }
                  },
                  boxShadow: '0 2px 8px rgba(0,0,0,0.1)',
                  animation: 'fadeIn 0.3s ease-in-out',
                  '@keyframes fadeIn': {
                    from: { opacity: 0, transform: 'translateY(-10px)' },
                    to: { opacity: 1, transform: 'translateY(0)' }
                  }
                }}
              />
            </Box>
          )}

          <Paper 
            variant="outlined" 
            sx={{ 
              p: 1.5, 
              m: 2, 
              mt: 0, 
              display: 'flex', 
              gap: 1.5, 
              alignItems: 'center',
              borderRadius: 3,
              bgcolor: 'grey.25',
              border: '1px solid',
              borderColor: 'grey.200',
              boxShadow: '0 2px 12px rgba(0,0,0,0.04)',
              '&:hover': {
                borderColor: 'primary.200',
                boxShadow: '0 4px 20px rgba(0,0,0,0.08)'
              },
              '&:focus-within': {
                borderColor: 'primary.main',
                boxShadow: '0 0 0 3px rgba(25, 118, 210, 0.12)'
              }
            }}
          >
            {/* 技能选择按钮 */}
            <IconButton 
              color={selectedSkill ? "primary" : "default"}
              aria-label="select skill" 
              onClick={() => setSkillDialogOpen(true)}
              sx={{ 
                flexShrink: 0,
                width: 40,
                height: 40,
                borderRadius: 2,
                bgcolor: selectedSkill ? 'primary.50' : 'grey.50',
                border: selectedSkill ? '1px solid' : '1px solid',
                borderColor: selectedSkill ? 'primary.200' : 'grey.200',
                color: selectedSkill ? 'primary.main' : 'grey.600',
                transition: 'all 0.2s ease-in-out',
                '&:hover': {
                  bgcolor: selectedSkill ? 'primary.100' : 'grey.100',
                  borderColor: selectedSkill ? 'primary.300' : 'grey.300',
                  transform: 'translateY(-1px)',
                  boxShadow: '0 4px 12px rgba(0,0,0,0.15)'
                }
              }}
              title="选择技能"
            >
              <ExtensionIcon fontSize="small" />
            </IconButton>
            
            <Box sx={{ position: 'relative', flex: 1 }}>
              {/* 技能提示覆盖层 */}
              {selectedSkill && (
                <Box sx={{
                  position: 'absolute',
                  left: 12,
                  top: '50%',
                  transform: 'translateY(-50%)',
                  zIndex: 1,
                  display: 'flex',
                  alignItems: 'center',
                  pointerEvents: 'none',
                  padding: '4px 8px',
                  borderRadius: 1,
                  '&:hover': {
                    bgcolor: 'rgba(25, 118, 210, 0.04)',
                    '& .close-button': {
                      opacity: 1,
                      visibility: 'visible'
                    }
                  }
                }}>
                  <Typography variant="body2" sx={{ 
                    color: 'primary.main', 
                    fontWeight: 500,
                    fontSize: '0.95rem',
                    mr: 0.5,
                    pointerEvents: 'auto',
                    cursor: 'default'
                  }}>
                    {skills.find(s => s.id === selectedSkill)?.name}
                  </Typography>
                  <IconButton 
                    className="close-button"
                    size="small" 
                    onClick={() => setSelectedSkill(null)}
                    sx={{ 
                      width: 18, 
                      height: 18, 
                      color: 'primary.main',
                      opacity: 0,
                      visibility: 'hidden',
                      transition: 'all 0.2s ease-in-out',
                      pointerEvents: 'auto',
                      '&:hover': { 
                        bgcolor: 'primary.100',
                        opacity: 1,
                        visibility: 'visible'
                      }
                    }}
                  >
                    <CloseIcon sx={{ fontSize: 14 }} />
                  </IconButton>
                </Box>
              )}
              
              <TextField
                fullWidth
                placeholder={selectedSkill === 'image_generation' ? "描述您想要生成的图像..." : "输入消息..."}
                value={input}
                onChange={e => setInput(e.target.value)}
                onKeyDown={e => {
                  if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    void handleSend();
                  }
                }}
                variant="standard"
                InputProps={{
                  disableUnderline: true,
                  sx: {
                    bgcolor: 'transparent',
                    fontSize: '0.95rem',
                    '& input': {
                      padding: selectedSkill ? '12px 16px 12px 100px' : '12px 16px',
                      borderRadius: 2,
                      bgcolor: 'white',
                      border: '1px solid',
                      borderColor: selectedSkill ? 'primary.200' : 'grey.200',
                      transition: 'all 0.2s ease-in-out',
                      '&:focus': {
                        borderColor: 'primary.main',
                        boxShadow: '0 0 0 3px rgba(25, 118, 210, 0.08)'
                      },
                      '&::placeholder': {
                        color: selectedSkill ? 'primary.600' : 'grey.500',
                        opacity: 1
                      }
                    }
                  }
                }}
              />
            </Box>
            <IconButton 
              color="primary" 
              aria-label="send" 
              onClick={() => void handleSend()}
              disabled={!input.trim()}
              sx={{
                flexShrink: 0,
                width: 44,
                height: 44,
                borderRadius: 2.5,
                bgcolor: input.trim() ? 'primary.main' : 'grey.200',
                color: input.trim() ? 'white' : 'grey.500',
                border: '1px solid',
                borderColor: input.trim() ? 'primary.main' : 'grey.300',
                transition: 'all 0.2s ease-in-out',
                '&:hover': {
                  bgcolor: input.trim() ? 'primary.dark' : 'grey.300',
                  transform: input.trim() ? 'translateY(-1px)' : 'none',
                  boxShadow: input.trim() ? '0 6px 20px rgba(25, 118, 210, 0.3)' : 'none'
                },
                '&:disabled': {
                  bgcolor: 'grey.200',
                  color: 'grey.400',
                  borderColor: 'grey.300'
                }
              }}
            >
              <SendIcon fontSize="small" />
            </IconButton>
          </Paper>

        </Paper>
      <Menu
        open={isMenuOpen}
        anchorEl={menuAnchor}
        onClose={() => { setMenuAnchor(null); setMenuConvId(null); }}
      >
        <MenuItem onClick={() => {
          const conv = conversations.find(c => c.id === menuConvId);
          setRenameValue(conv?.title ?? '');
          setRenameOpen(true);
          setMenuAnchor(null);
        }}>重命名</MenuItem>
        <MenuItem onClick={() => { setDeleteOpen(true); setMenuAnchor(null); }}>删除</MenuItem>
      </Menu>

      <Dialog open={renameOpen} onClose={() => setRenameOpen(false)}>
        <DialogTitle>重命名对话</DialogTitle>
        <DialogContent>
          <TextField autoFocus fullWidth value={renameValue} onChange={e => setRenameValue(e.target.value)} />
        </DialogContent>
        <DialogActions>
          <Button onClick={() => setRenameOpen(false)}>取消</Button>
          <Button variant="contained" onClick={() => { if (menuConvId) handleRenameConversation(menuConvId, renameValue.trim() || '未命名对话'); setRenameOpen(false); }}>确定</Button>
        </DialogActions>
      </Dialog>

      <Dialog open={deleteOpen} onClose={() => setDeleteOpen(false)}>
        <DialogTitle>删除对话</DialogTitle>
        <DialogContent>
          <Typography>此操作将删除选中的对话及其消息，是否继续？</Typography>
        </DialogContent>
        <DialogActions>
          <Button onClick={() => setDeleteOpen(false)}>取消</Button>
          <Button color="error" variant="contained" onClick={() => { if (menuConvId) handleDeleteConversation(menuConvId); setDeleteOpen(false); }}>删除</Button>
        </DialogActions>
      </Dialog>

      <Dialog open={clearChatOpen} onClose={() => setClearChatOpen(false)}>
        <DialogTitle>清除聊天记录</DialogTitle>
        <DialogContent>
          <Typography>此操作将清除当前对话的所有消息，但保留对话本身。是否继续？</Typography>
        </DialogContent>
        <DialogActions>
          <Button onClick={() => setClearChatOpen(false)}>取消</Button>
          <Button color="error" variant="contained" onClick={() => { handleClearCurrentChat(); setClearChatOpen(false); }}>清除</Button>
        </DialogActions>
      </Dialog>

      <Dialog open={memorySettingsOpen} onClose={() => setMemorySettingsOpen(false)} maxWidth="sm" fullWidth>
        <DialogTitle>记忆设置</DialogTitle>
        <DialogContent>
          <Stack spacing={3} sx={{ mt: 1 }}>
            <Box>
              <Typography variant="subtitle2" sx={{ mb: 1 }}>聊天记忆轮数</Typography>
              <Typography variant="body2" color="text.secondary" sx={{ mb: 2 }}>
                控制 AI 能记住多少轮对话历史。一轮包含一次用户提问和 AI 回答。
              </Typography>
              <FormControl fullWidth>
                <InputLabel>记忆轮数</InputLabel>
                <Select
                  value={memorySettings.maxRounds}
                  label="记忆轮数"
                  onChange={(e) => setMemorySettings(prev => ({ ...prev, maxRounds: Number(e.target.value) }))}
                >
                  <MenuItem value={3}>3 轮</MenuItem>
                  <MenuItem value={5}>5 轮</MenuItem>
                  <MenuItem value={10}>10 轮</MenuItem>
                  <MenuItem value={20}>20 轮</MenuItem>
                  <MenuItem value={50}>50 轮</MenuItem>
                  <MenuItem value={100}>100 轮</MenuItem>
                </Select>
              </FormControl>
            </Box>
          </Stack>
        </DialogContent>
        <DialogActions>
          <Button onClick={() => setMemorySettingsOpen(false)}>关闭</Button>
        </DialogActions>
      </Dialog>

      {/* RAG 设置对话框 */}
      <Dialog open={ragSettingsOpen} onClose={() => setRAGSettingsOpen(false)} maxWidth="sm" fullWidth>
        <DialogTitle>知识检索设置</DialogTitle>
        <DialogContent>
          <Stack spacing={3} sx={{ mt: 1 }}>
            <Box>
              <Typography variant="subtitle2" sx={{ mb: 1 }}>启用 RAG 检索</Typography>
              <Typography variant="body2" color="text.secondary" sx={{ mb: 2 }}>
                开启后，AI 会自动检索知识库中的相关信息来回答问题。
              </Typography>
              <FormControl fullWidth>
                <InputLabel>检索状态</InputLabel>
                <Select
                  value={ragSettings.enabled ? 'enabled' : 'disabled'}
                  label="检索状态"
                  onChange={(e) => setRAGSettings(prev => ({ ...prev, enabled: e.target.value === 'enabled' }))}
                >
                  <MenuItem value="enabled">✅ 启用检索</MenuItem>
                  <MenuItem value="disabled">❌ 禁用检索</MenuItem>
                </Select>
              </FormControl>
            </Box>

            {ragSettings.enabled && (
              <Box>
                <Typography variant="subtitle2" sx={{ mb: 1 }}>检索结果数量</Typography>
                <Typography variant="body2" color="text.secondary" sx={{ mb: 2 }}>
                  控制每次检索返回的知识库片段数量。更多结果提供更全面的信息，但可能影响响应速度。
                </Typography>
                <FormControl fullWidth>
                  <InputLabel>结果数量</InputLabel>
                  <Select
                    value={ragSettings.maxResults}
                    label="结果数量"
                    onChange={(e) => setRAGSettings(prev => ({ ...prev, maxResults: Number(e.target.value) }))}
                  >
                    <MenuItem value={1}>1 个结果</MenuItem>
                    <MenuItem value={2}>2 个结果</MenuItem>
                    <MenuItem value={3}>3 个结果</MenuItem>
                    <MenuItem value={5}>5 个结果</MenuItem>
                  </Select>
                </FormControl>
              </Box>
            )}

            <Alert severity="info" sx={{ mt: 2 }}>
              <Typography variant="body2">
                📚 当前知识库状态：{getKnowledgeSources().filter(s => s.status === 'active').length} 个激活的知识源
              </Typography>
            </Alert>
          </Stack>
        </DialogContent>
        <DialogActions>
          <Button onClick={() => setRAGSettingsOpen(false)}>关闭</Button>
        </DialogActions>
      </Dialog>

      {/* 指令选择对话框 */}
      <Dialog open={commandDialogOpen} onClose={() => setCommandDialogOpen(false)} maxWidth="md" fullWidth>
        <DialogTitle>选择指令模板</DialogTitle>
        <DialogContent>
          <Stack spacing={2} sx={{ mt: 1 }}>
            {/* 搜索框 */}
            <TextField
              fullWidth
              placeholder="搜索指令..."
              value={commandSearchText}
              onChange={(e) => setCommandSearchText(e.target.value)}
              InputProps={{
                startAdornment: <SearchIcon sx={{ mr: 1, color: 'text.secondary' }} />
              }}
            />

            {/* 指令列表 */}
            <Box sx={{ maxHeight: 400, overflow: 'auto' }}>
              {['personal', 'public'].map((category) => {
                const categoryCommands = commands
                  .filter(cmd => cmd.category === category)
                  .filter(cmd => 
                    !commandSearchText || 
                    cmd.name.toLowerCase().includes(commandSearchText.toLowerCase()) ||
                    cmd.description.toLowerCase().includes(commandSearchText.toLowerCase())
                  );

                if (categoryCommands.length === 0) return null;

                return (
                  <Box key={category} sx={{ mb: 2 }}>
                    <Typography variant="subtitle2" color="text.secondary" sx={{ mb: 1, px: 1 }}>
                      {category === 'personal' ? '我的指令' : '公开指令'}
                    </Typography>
                    <Stack spacing={1}>
                      {categoryCommands.map((command) => (
                        <Paper
                          key={command.id}
                          variant="outlined"
                          sx={{
                            p: 2,
                            cursor: 'pointer',
                            border: selectedCommandId === command.id ? 2 : 1,
                            borderColor: selectedCommandId === command.id ? 'primary.main' : 'divider',
                            bgcolor: selectedCommandId === command.id ? 'primary.50' : 'transparent',
                            '&:hover': {
                              bgcolor: selectedCommandId === command.id ? 'primary.100' : 'grey.50'
                            }
                          }}
                          onClick={() => {
                            setSelectedCommandId(command.id);
                            setCommandDialogOpen(false);
                            setCommandSearchText('');
                          }}
                        >
                          <Typography variant="subtitle2" sx={{ fontWeight: 600, mb: 0.5 }}>
                            {command.name}
                          </Typography>
                          <Typography variant="body2" color="text.secondary" sx={{ mb: 1 }}>
                            {command.description}
                          </Typography>
                          <Typography variant="caption" color="text.secondary" sx={{ 
                            display: 'block',
                            whiteSpace: 'pre-line',
                            bgcolor: 'grey.50',
                            p: 1,
                            borderRadius: 1,
                            fontFamily: 'monospace'
                          }}>
                            {command.todoList.split('\n').slice(0, 3).join('\n')}
                            {command.todoList.split('\n').length > 3 && '\n...'}
                          </Typography>
                        </Paper>
                      ))}
                    </Stack>
                  </Box>
                );
              })}

              {commands.filter(cmd => 
                !commandSearchText || 
                cmd.name.toLowerCase().includes(commandSearchText.toLowerCase()) ||
                cmd.description.toLowerCase().includes(commandSearchText.toLowerCase())
              ).length === 0 && (
                <Box sx={{ textAlign: 'center', py: 4 }}>
                  <Typography color="text.secondary">
                    {commandSearchText ? '未找到匹配的指令' : '暂无可用指令'}
                  </Typography>
                </Box>
              )}
            </Box>
          </Stack>
        </DialogContent>
        <DialogActions>
          {selectedCommandId && (
            <Button 
              onClick={() => {
                setSelectedCommandId('');
              }}
              color="error"
            >
              清除选择
            </Button>
          )}
          <Button onClick={() => setCommandDialogOpen(false)}>关闭</Button>
        </DialogActions>
      </Dialog>

      {/* 技能选择弹窗 */}
      <Dialog
        open={skillDialogOpen}
        onClose={() => setSkillDialogOpen(false)}
        maxWidth="sm"
        fullWidth
      >
        <DialogTitle>选择技能</DialogTitle>
        <DialogContent>
          <Stack spacing={2} sx={{ mt: 1 }}>
            {skills.map((skill) => (
              <Paper
                key={skill.id}
                variant="outlined"
                sx={{
                  p: 2,
                  cursor: 'pointer',
                  border: selectedSkill === skill.id ? 2 : 1,
                  borderColor: selectedSkill === skill.id ? 'primary.main' : 'divider',
                  bgcolor: selectedSkill === skill.id ? 'primary.50' : 'transparent',
                  transition: 'all 0.2s ease-in-out',
                  '&:hover': {
                    bgcolor: selectedSkill === skill.id ? 'primary.100' : 'grey.50',
                    transform: 'translateY(-1px)',
                    boxShadow: '0 4px 12px rgba(0,0,0,0.1)'
                  }
                }}
                onClick={() => {
                  setSelectedSkill(skill.id);
                  setSkillDialogOpen(false);
                }}
              >
                <Box sx={{ display: 'flex', alignItems: 'center', gap: 2 }}>
                  <ExtensionIcon sx={{ 
                    color: selectedSkill === skill.id ? 'primary.main' : 'grey.600',
                    fontSize: 24 
                  }} />
                  <Box>
                    <Typography variant="subtitle1" sx={{ fontWeight: 600, mb: 0.5 }}>
                      {skill.name}
                    </Typography>
                    <Typography variant="body2" color="text.secondary">
                      {skill.description}
                    </Typography>
                  </Box>
                </Box>
              </Paper>
            ))}
          </Stack>
        </DialogContent>
        <DialogActions>
          {selectedSkill && (
            <Button 
              onClick={() => setSelectedSkill(null)}
              color="error"
            >
              清除选择
            </Button>
          )}
          <Button onClick={() => setSkillDialogOpen(false)}>关闭</Button>
        </DialogActions>
      </Dialog>

      {/* 图片放大弹窗 */}
      <Dialog
        open={imageModalOpen.open}
        onClose={() => setImageModalOpen({ open: false, src: '' })}
        maxWidth="lg"
        fullWidth
      >
        <DialogContent sx={{ p: 1, textAlign: 'center' }}>
          {imageModalOpen.src && (
            <img
              src={imageModalOpen.src}
              alt="Generated image"
              style={{
                maxWidth: '100%',
                maxHeight: '80vh',
                height: 'auto',
                borderRadius: '8px'
              }}
            />
          )}
        </DialogContent>
        <DialogActions>
          <Button
            startIcon={<SaveIcon />}
            onClick={() => {
              const link = document.createElement('a');
              link.href = imageModalOpen.src;
              link.download = `generated-image-${Date.now()}.png`;
              document.body.appendChild(link);
              link.click();
              document.body.removeChild(link);
            }}
          >
            保存图片
          </Button>
          <Button onClick={() => setImageModalOpen({ open: false, src: '' })}>
            关闭
          </Button>
        </DialogActions>
      </Dialog>
    </Stack>
  );
}


